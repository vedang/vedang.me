<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Notes on Vedang Manerikar</title><link>https://vedang.me/notes/</link><description>Recent content in Notes on Vedang Manerikar</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 26 Mar 2020 21:27:00 +0530</lastBuildDate><atom:link href="https://vedang.me/notes/index.xml" rel="self" type="application/rss+xml"/><item><title>Doug McIlroy: the UNIX philosophy</title><link>https://vedang.me/notes/doug-mcilroy-unix-philosophy/</link><pubDate>Sat, 22 Aug 2020 18:11:52 +0530</pubDate><guid>https://vedang.me/notes/doug-mcilroy-unix-philosophy/</guid><description>Snippet from: The Art of Unix Programming
Make each program do one thing well. To do a new job, build afresh rather than complicate old programs by adding new features.
Expect the output of every program to become the input to another, as yet unknown, program. Don&amp;rsquo;t clutter output with extraneous information. Avoid stringently columnar or binary input formats. Don&amp;rsquo;t insist on interactive input.
Design and build software, even operating systems, to be tried early, ideally within weeks.</description></item><item><title>ESR: the UNIX Philosophy</title><link>https://vedang.me/notes/esr-unix-philosophy/</link><pubDate>Sat, 22 Aug 2020 18:11:52 +0530</pubDate><guid>https://vedang.me/notes/esr-unix-philosophy/</guid><description>Snippet from: The Art of Unix Programming
Rule of Modularity Write simple parts connected by clean interfaces. Rule of Clarity Clarity is better than cleverness. Rule of Composition Design programs to be connected to other programs. Rule of Separation Separate policy from mechanism; separate interfaces from engines. Rule of Simplicity Design for simplicity; add complexity only where you must. Rule of Parsimony Write a big program only when it is clear by demonstration that nothing else will do.</description></item><item><title>Gene Kim: The Five Ideals of DevOps</title><link>https://vedang.me/notes/gene-kim-the-five-ideals/</link><pubDate>Sat, 22 Aug 2020 18:11:52 +0530</pubDate><guid>https://vedang.me/notes/gene-kim-the-five-ideals/</guid><description>Snippet from: The Unicorn Project, along with my own notes
The First Ideal Locality and Simplicity. Build simple, decoupled systems that can iterate in isolation. The Second Ideal Focus, Flow and Joy. Work in small batches with fast and continuous feedback. The Third Ideal Improvement of Daily Work. Make sure that daily work can be done with minimum impediments. Prioritize productivity over everything else. The Fourth Ideal Psychological Safety. Solving problems requires preventing problems, which requires honesty, which requires the absence of fear.</description></item><item><title>Gene Kim: The Four Types of Work</title><link>https://vedang.me/notes/gene-kim-the-four-types/</link><pubDate>Sat, 22 Aug 2020 18:11:52 +0530</pubDate><guid>https://vedang.me/notes/gene-kim-the-four-types/</guid><description>Snippet from: The Phoenix Project, along with my own notes
Business Projects &amp;ldquo;Feature Work&amp;rdquo;. This is the most visible type of work. Internal IT Projects Release Automation, QA Automation, Developer Tooling and other internal enablers. Mostly un-tracked and invisible, but crucial to long-term success. Updates and Changes Generally generated from above to categories of work. Introduces delay as breadth of existing surface area increases. Unplanned Work Fire-fighting at all levels of the company.</description></item><item><title>Gene Kim: The Three Ways of doing excellent Work</title><link>https://vedang.me/notes/gene-kim-the-three-ways/</link><pubDate>Sat, 22 Aug 2020 18:11:52 +0530</pubDate><guid>https://vedang.me/notes/gene-kim-the-three-ways/</guid><description>Snippet from: The Phoenix Project, along with my own notes
Flow Maximizing the rate of flow of work is the key to success. Limiting the work in progress is the fastest way to achieve Flow. Fast Feedback Setup systems to get fast feedback at every stage of work, from concept through shipping to maintaining in production. Experimentation and Learning Keep dedicated time for experiments, at every level of the company.</description></item><item><title>L Peter Deutsch: The Fallacies of Distributed Computing</title><link>https://vedang.me/notes/l-peter-deutsch-the-fallacies-of-distributed-computing/</link><pubDate>Sat, 22 Aug 2020 18:11:52 +0530</pubDate><guid>https://vedang.me/notes/l-peter-deutsch-the-fallacies-of-distributed-computing/</guid><description>Snippet from: The Wikipedia Article, along with my own notes
The network is reliable Think about error-handling on network failures. Use the following patterns: Timeouts, Retries, Circuit breakers, Graceful Degradation. Latency is zero Think about bandwidth requirements and packet loss. Use the following patterns: Small payloads, Compression, Asynchronous Communication, Perceived Progress, Timeouts, Graceful Degradation. Bandwidth is infinite The same as above. Think explicitly about bottlenecks in Network traffic. Use the following patterns: Caching, Etags.</description></item><item><title>Rob Pike: Rules of Programming</title><link>https://vedang.me/notes/rob-pike-rules/</link><pubDate>Sat, 22 Aug 2020 18:11:52 +0530</pubDate><guid>https://vedang.me/notes/rob-pike-rules/</guid><description>Snippet from: Notes on C Programming
No Speed Hacks You can&amp;rsquo;t tell where a program is going to spend its time. Bottlenecks occur in surprising places, so don&amp;rsquo;t try to second guess and put in a speed hack until you&amp;rsquo;ve proven that&amp;rsquo;s where the bottleneck is. Measure before tuning Don&amp;rsquo;t tune for speed until you&amp;rsquo;ve measured, and even then don&amp;rsquo;t unless one part of the code overwhelms the rest. No Fancy Algorithms Fancy algorithms are slow when n is small, and n is usually small.</description></item><item><title>Tim Peters: The Python Way</title><link>https://vedang.me/notes/tim-peters-the-python-way/</link><pubDate>Sat, 22 Aug 2020 18:11:52 +0530</pubDate><guid>https://vedang.me/notes/tim-peters-the-python-way/</guid><description>Snippet from: The Python Mailing List
Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren&amp;rsquo;t special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.</description></item><item><title>Lazy Weekend Viewing: Preventing the collapse of civilization</title><link>https://vedang.me/notes/preventing-the-collapse-of-civilization/</link><pubDate>Sun, 12 Apr 2020 18:20:00 +0530</pubDate><guid>https://vedang.me/notes/preventing-the-collapse-of-civilization/</guid><description>&amp;ldquo;Preventing the Collapse of Civilization&amp;rdquo; is an excellent talk by Jonathan Blow (of Braid fame) at DevGAMM 2019. It&amp;rsquo;s inspiring and I recommend you make the time to see it. My notes below:
Summary It is a myth that technology only advances. We&amp;rsquo;ve often seen significant backward slides in tech. (Lots of examples to illustrate this point) Software is in decline. Both software robustness and programmer productivity is declining. (Lots of examples to illustrate this point) We need to fight complexity and strive for simplicity in every step if we want to battle degradation and loss of capability.</description></item><item><title>Lazy Weekend Reading: A love letter to Clojure</title><link>https://vedang.me/notes/love-letter-to-clojure/</link><pubDate>Sun, 13 Oct 2019 23:02:00 +0530</pubDate><guid>https://vedang.me/notes/love-letter-to-clojure/</guid><description>I had no idea that Gene Kim, author of three books that have garnered wide-spread public acclaim, was doing Clojure programming. (They are DevOps Handbook, Phoenix Project, and Accelerate &amp;ndash; we&amp;rsquo;ve ordered them recently for the Helpshift Library). He published a love-letter to Clojure this weekend, and I think it is an absolute must-read for all programmers (whether you write Clojure or not). The blog-post covers the following areas:
General software philosophy Choose tools that are good to think with Most bugs are due to programmers not understanding all the possible states their code may execute in.</description></item><item><title>Lazy Weekend Viewing: GOJEK's 10x Engineer - Truth or Myth?</title><link>https://vedang.me/notes/gojek-10x-engineering/</link><pubDate>Sat, 20 Jul 2019 07:39:00 +0530</pubDate><guid>https://vedang.me/notes/gojek-10x-engineering/</guid><description>&lt;h2 id="summary">Summary&lt;/h2>
&lt;ul>
&lt;li>Engineering quality is paramount. Focus on &lt;a href="https://dave.cheney.net/2019/07/09/clear-is-better-than-clever">clean and clear code&lt;/a>.
Code is the primary medium of communication for any engineer.
Write beautiful code and hold people to high standards.&lt;/li>
&lt;li>Adding head count has vast hidden costs and often brings down
output. The reason for this is the exponential increase in
communication required to align everyone to common goals.&lt;/li>
&lt;li>Similarly, pods cannot scale unless they can own small,
independent components.&lt;/li>
&lt;li>Monoliths are normal and good when the company is small.
Refactoring the monolithic model into different components allows
us to scale pods and org.&lt;/li>
&lt;li>Carve monoliths only when it hits critical mass. Then, identify
the pain and pull it out into it&amp;rsquo;s own pod.&lt;/li>
&lt;li>&amp;ldquo;Relationship as a service&amp;rdquo; or &amp;ldquo;Please get this done for me over
and above other stuff on your plate&amp;rdquo;
&lt;ul>
&lt;li>&amp;ldquo;Traffic congestion&amp;rdquo; (A team which is too busy) and structural
failure can lead to the impression that the system is
bureaucratic and political.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Criteria when hiring Engineers
&lt;ul>
&lt;li>Computer science (Can computers understand your code?)
&lt;ul>
&lt;li>Ability to grasp large complex systems&lt;/li>
&lt;li>Understanding of implications of design choices on that system.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Software Engineering (Can humans understand your code?)
&lt;ul>
&lt;li>How well do you communicate through your code? This is the
metric that enables building &lt;strong>good&lt;/strong> systems.&lt;/li>
&lt;li>The hygiene you show in code is the hygiene you will enforce
on others.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Good behavioral traits (Can you grow?)
&lt;ul>
&lt;li>Curious&lt;/li>
&lt;li>Wants to learn&lt;/li>
&lt;li>Can accept feedback&lt;/li>
&lt;li>&amp;ldquo;Strong opinions, Weakly held.&amp;rdquo;&lt;/li>
&lt;li>&amp;ldquo;Pride without attachment.&amp;rdquo;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Find the full video &lt;a href="https://www.youtube.com/watch?v=He0XBBfCEVk">here&lt;/a>!&lt;/li>
&lt;li>The rest of this post is detailed notes on the video&lt;/li>
&lt;/ul></description></item></channel></rss>