<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vedang Manerikar</title>
  <link href="https://vedang.me/planetclojure.xml" rel="self"/>
  <link href="https://vedang.me/"/>
  <updated>2023-05-24T15:49:07+05:30</updated>
  <id>https://vedang.me/</id>
  <author>
    <name>Vedang Manerikar</name>
  </author>
  <entry>
    <id>tabfs-and-automation.html</id>
    <link href="tabfs-and-automation.html"/>
    <title>TabFS and Automation</title>
    <updated>2022-09-20T22:20:00+00:00</updated>
    <content type="html"><![CDATA[<p><div class="ox-neuron-main"> <div class="ox-neuron-article"> <h1 class="ox-neuron-article-heading">TabFS and Automation</h1> <div class="ox-neuron-article-contents"> Hello reader! This is a short update about the very cool <a href='https://omar.website/tabfs/'>TabFS</a>, which is a browser extension that maps your open tabs to the filesystem using Fuse. Think <code>/proc</code> but for the browser. This is an excellent idea, because now I can run all the tools that I am already familiar with on my tabs!</p><p>As I was reading through the TabFS page (linked above), I thought to myself: "this is so much RC energy!". So I checked, and lo and behold, Omar Rizwan is an RC Alum :D</p><h2 id="why-i-wanted-something-like-tabfs">Why I wanted something like TabFS</h2><p>The internet is full of interesting stuff that hijacks my attention. I end up getting completely distracted from my planned tasks. My solution to this is: I open all the links I want, but I don't read anything immediately. Instead, I capture the link in Org-Mode and schedule it for later (generally tomorrow). This way, when I am planning the day, I have a bunch of links in my Agenda. I choose which ones I want to read on any given day and defer / delete the rest. I use the excellent <a href='https://orgmode.org/manual/Agenda-Commands.html'>Bulk Scatter</a> tool built into Org Agenda for this.</p><p>I thought: Why do this manually? Enter TabFS</p><h2 id="a-small-babashka-script">A small Babashka script</h2><p>With TabFS installed, it was a small step to go from there to <code>org-mode</code>. My go-to scripting tool is <a href='https://book.babashka.org/'>Babashka</a>. Here is the meat of the code:</p><pre><code class="lang-clojure">&#40;require '&#91;babashka.fs :as fs&#93;
         '&#91;clojure.string :as cs&#93;&#41;

&#40;defn build-tab-info
  &quot;Collects the title and URL for all open tabs using TabFS.&quot;
  &#91;opts&#93;
  &#40;map &#40;fn &#91;t&#93;
         {:title &#40;first &#40;fs/read-all-lines &#40;str t &quot;/title.txt&quot;&#41;&#41;&#41;
          :url &#40;first &#40;fs/read-all-lines &#40;str t &quot;/url.txt&quot;&#41;&#41;&#41;}&#41;
       &#40;fs/list-dir &#40;:tab-dir opts&#41;&#41;&#41;&#41;

&#40;def plain-text-template
  &quot;The template for creating the org-mode plain-text entry. Placeholders
are for the following items &#40;in order&#41;:
  1. Org-Mode Heading level: default value is 1.
  2. URL of the link to the stored.
  3. Title of the link to be stored.
  4. Date when the Tab is scheduled for reading: default is tomorrow.
  5. Date when the Tab was captured.&quot;
  &quot;%s TODO &#91;&#91;%s&#93;&#91;%s&#93;&#93;\nSCHEDULED: %s\n%s&quot;&#41;

&#40;defn tabs-&gt;text
  &quot;Convert the list of open tabs to a wall of text that can be stored in
  Plain-Text.&quot;
  &#91;opts&#93;
  &#40;-&gt;&gt; &#40;build-tab-info opts&#41;
       &#40;map &#40;fn &#91;t&#93;
              &#40;format plain-text-template
                      &#40;apply str &#40;repeat &#40;:org-mode-heading-level opts&#41; &quot;&#42;&quot;&#41;&#41;
                      &#40;:url t&#41;
                      &#40;:title t&#41;
                      &#40;:scheduled-on opts&#41;
                      &#40;:captured-on opts&#41;&#41;&#41;&#41;
       &#40;cs/join \newline&#41;&#41;&#41;
</code></pre><p>I wrote a <a href='https://github.com/vedang/bb-scripts#bb-plain-text-tabs'>CLI script</a> for the code, here is what the <code>help</code> command looks like:</p><pre><code class="lang-text">✦ ➜ bb-plain-text-tabs --help
Convert all open tabs to plain text Org Mode format. Optionally, close the open tabs.

Usage: bb-plain-text-tabs &#91;options&#93;

Options:
  -fs,  --tabfs-mnt-path                &#42;REQUIRED&#42; TabFS mount path. The path on the filesystem where TabFS is mounted.
  -hl,  --org-mode-heading-level        1                            The heading level at which link headings will be stored in Org Mode.
  -s,   --scheduled-on           &lt;date&gt; tomorrow                     Date on which to schedule reading this batch of links, in yyyy-MM-dd format.
  -del, --delete-tabs            &lt;del&gt;  false                        Boolean value to indicate if browser tabs should be closed

Examples:
   bb-plain-text-tabs -fs &lt;TabFS Mount Path&gt; # Convert Open Tabs to Plain Text
   bb-plain-text-tabs -fs &lt;TabFS Mount Path&gt; --delete-tabs # Delete tabs and print plain text
   bb-plain-text-tabs -fs &lt;TabFS Mount Path&gt; | tee tabs.org # Capture Plain Text output to file
</code></pre><h2 id="what-it-looks-like">What it looks like</h2><p>Finally, this is the output, in Org Mode:</p><p><img src="./static/images/tabfs.png" alt="" /></p><p>I hope all the Emacs/Org-mode folks reading this find it useful! Thank you to Omar for the excellent <a href='https://omar.website/tabfs/'>TabFS</a> tool!</p><p></div> </div> </div></p>]]></content>
  </entry>
  <entry>
    <id>clj-rebl-lein-cider-emacs.html</id>
    <link href="clj-rebl-lein-cider-emacs.html"/>
    <title>How to use the Clojure REBL with Leiningen, Cider and Emacs</title>
    <updated>2020-10-28T23:18:00+00:00</updated>
    <content type="html"><![CDATA[<p><div class="ox-neuron-main"> <div class="ox-neuron-article"> <h1 class="ox-neuron-article-heading">How to use the Clojure REBL with Leiningen, Cider and Emacs</h1> <div class="ox-neuron-article-contents"> <strong>Note</strong>: This set of instructions only work on <strong>Clojure 1.10+</strong>, <strong>Lein 2.9+</strong> and <strong>JDK 11+</strong>. Also, REBL requires a license for commercial use.</p><p>I didn't find a handy reference to getting started with REBL if your primary workflow is Leiningen/nrepl, so here is the series of things I had to do to get the REBL up and running for myself.</p><ol><li>Download the <a href='https://docs.datomic.com/cloud/other-tools/REBL.html'>REBL jar</a> from Cognitect.</li><li>Use <a href='https://github.com/kumarshantanu/lein-localrepo'>lein-localrepo</a> to install the REBL jar to your m2.<pre><code class="lang-shell-script">    lein localrepo install rebl-0.9.242/rebl-0.9.242.jar com.cognitect/rebl 0.9.242
    </code></pre></li><li>Add the following code to your <code>profiles.clj</code> file (code below). This is based on the <a href='https://docs.datomic.com/cloud/other-tools/REBL.html#installation'>REBL installation guide</a> and <a href='https://github.com/RickMoynihan/nrebl.middleware'>Rick Moynihan's nrepl middleware</a>:<pre><code class="lang-clojure">    {
     ;; ....
     ;; You other profiles stuff
     ;; ....
     :rebl {:plugins &#91;&#91;cider/cider-nrepl &quot;0.25.3&quot;&#93;
                      &#91;refactor-nrepl &quot;2.5.0&quot;&#93;
                      &#91;nrepl &quot;0.8.2&quot;&#93;&#93;
            :repl-options {:nrepl-middleware &#91;nrebl.middleware/wrap-nrebl&#93;}
            :dependencies &#91;&#91;org.clojure/tools.deps.alpha &quot;0.7.511&quot;&#93;
                           &#91;com.cognitect/rebl &quot;0.9.242&quot;&#93;
                           &#91;org.clojure/core.async &quot;1.3.610&quot;&#93;
                           &#91;cljfmt  &quot;0.6.4&quot;&#93;
                           &#91;rickmoynihan/nrebl.middleware &quot;0.3.1&quot;&#93;
                           &#91;org.openjfx/javafx-fxml &quot;15-ea+6&quot;&#93;
                           &#91;org.openjfx/javafx-controls &quot;15-ea+6&quot;&#93;
                           &#91;org.openjfx/javafx-swing &quot;15-ea+6&quot;&#93;
                           &#91;org.openjfx/javafx-base &quot;15-ea+6&quot;&#93;
                           &#91;org.openjfx/javafx-web &quot;15-ea+6&quot;&#93;&#93;}
     ;; ....
     ;; If you don't have anything in your profiles.clj right now, just
     ;; remove the comments and copy the whole map over.
     }
    </code></pre></li><li>Start the REPL with the new profile<pre><code class="lang-shell-script">    lein with-profile +rebl repl :headless
    </code></pre></li><li>Connect to the REPL from Emacs. Do this by opening up any Clojure file in your project and executing <code>M-x cider-connect</code> in the file.</li><li>Run the following commands in the REPL to spin up the REBL.<pre><code class="lang-clojure">    &#40;require '&#91;cognitect.rebl :as rebl&#93;&#41;
    &#40;rebl/ui&#41;
    </code></pre></li><li>At this point, anything that you evaluate when programming will be sent to your REPL as well as to your REBL and can be inspected from there. Anything you evaluate into the REPL will be sent over to the REBL as well.</li><li>Work on the REPL as you normally would. Your work is also being sent into the REBL for fancy viewing when you need it.</li></ol><p></div> </div> </div></p>]]></content>
  </entry>
  <entry>
    <id>love-letter-to-clojure.html</id>
    <link href="love-letter-to-clojure.html"/>
    <title>Lazy Weekend Reading: A love letter to Clojure</title>
    <updated>2019-10-13T23:02:00+00:00</updated>
    <content type="html"><![CDATA[<p><div class="ox-neuron-main"> <div class="ox-neuron-toc"> <div class="ox-neuron-toc-contents"> <div class="ox-neuron-toc-heading">Table of Contents</div> <div class="ox-neuron-toc-items"></p><ul><li><a href='#general-software-philosophy'>General software philosophy</a></li><li><a href='#specific-programming-practices'>Specific Programming Practices</a></li><li><a href='#the-joy-of-clojure'>The Joy of Clojure</a></li><li><a href='#other-notes'>Other notes</a></li><li><a href='#resources'>Resources:</a></div></div></div></li></ul><p><div class="ox-neuron-article"> <h1 class="ox-neuron-article-heading">Lazy Weekend Reading: A love letter to Clojure</h1> <div class="ox-neuron-article-contents"> I had no idea that <i>Gene Kim</i>, author of three books that have garnered wide-spread public acclaim, was doing Clojure programming. (They are DevOps Handbook, Phoenix Project, and Accelerate -- we've ordered them recently for the Helpshift Library). He published <a href='https://itrevolution.com/love-letter-to-clojure-part-1/'>a love-letter to Clojure</a> this weekend, and I think it is an absolute must-read for <strong>all programmers</strong> (whether you write Clojure or not). The blog-post covers the following areas:</p><h2 id="general-software-philosophy">General software philosophy</h2><ul><li>Choose tools that are good to <strong>think</strong> with</li><li>Most bugs are due to programmers not understanding all the possible states their code may execute in. <strong>Make state and it's mutation explicit</strong>. Put it in a specific place and mutate it with a small set of specific functions.</li><li><strong>Conventions matter</strong>. They help readability of code, which is critical.</li><li><strong>Make systems simple to change</strong>. Don't "trap yourself in a system of work where you can no longer solve real business problems easily. Instead, you’re forced to merely solve puzzles all day, trying to figure out how to make your small change, obstructed by your complected system".</li><li>Developer productivity is enhanced when they follow the ideals listed below. Invisible structures around us either help or hinder in this regard.<ul><li>The first ideal: <strong>Locality and Simplicity</strong></li><li>The second ideal: <strong>Focus, Flow and Joy</strong></li><li>The third ideal: <strong>Improvement of Daily Work</strong></li><li>The fourth ideal: <strong>Psychological Safety</strong></li><li>The fifth ideal: <strong>Customer Focus</strong></li></ul></li><li>"Practice as a transcendental experience" and "Practice as hard work and perseverance" are both needed for developers to level up.</li><li>Bugs can be introduced by not understanding programming language constructs (eg: in Ruby, strings are mutated if you use the &lt;&lt; operator).</li></ul><h2 id="specific-programming-practices">Specific Programming Practices</h2><ul><li><strong>Pure functions are trivial to test</strong> -- build input, look at output. If it's hard to write a test for your code, that's a sign that it is complicated. Try to simplify it by pulling pure functions out of it and writing tests for those.</li><li><strong>Push side-effects (impure functions) to the edge of the program</strong> / piece of code that you are writing. Not practicing this leads to code becoming increasingly untestable and difficult to change.<ul><li>example of good vs bad way:<pre><code class="lang-clojure">
        ;; good way: steps are composed together, which each compiler phase
        ;; indepdendently executable and testable.

        &#40;-&gt; &#40;tokenize-source-files!&#41;
            &#40;generate-abstract-syntax-tree&#41;
            &#40;generate-intermediate-representation&#41;
            &#40;generate-assembly-instructions&#41;
            &#40;write-assembly-output-files!&#41;&#41;

        ;; bad way: all the intermediate steps buried inside other functions,
        ;; no longer reachable or inspectable.

        tokenize-source-files-and-generate-ir-and-generate-assembly&#40;&#41;;
        </code></pre></li></ul></li><li>Pushing I/O to edges reduces the need for mocks and stubs</li></ul><h2 id="the-joy-of-clojure">The Joy of Clojure</h2><ul><li>Ease of writing short, beautiful code that just works.</li><li>Simpler syntax frees your brain to think about the problem you want to solve.</li><li>The REPL experience enables developer to stay focused and in flow state. The developer experiences joy in REPL driven development.</li><li>Clojure is a high-level language that gets out of your way. "A programming language is low-level when its programs require attention to the irrelevant." - Alan Perlis</li></ul><h2 id="other-notes">Other notes</h2><ul><li>The brightest days of infrastructure, operations and security are still ahead of us. They involve providing platforms to developers that hide the complexity of these things and allow the developer to focus on the business problem they want to solve.</li></ul><h2 id="resources">Resources:</h2><ul><li>Some great blog-posts:<ul><li>Bryan Cantrell: <a href='https://twitter.com/bcantrill/status/1042180114199375872'>A love letter to Rust</a> (which inspired this post)</li><li>John Carmack: <a href='http://www.gamasutra.com/view/news/169296/Indepth%5C_Functional%5C_programming%5C_in%5C_C.php'>The power of functional programming concepts in C++</a></li><li>Shu Uesugi and Julien Benchetrit: <a href='https://medium.freecodecamp.org/react-introduction-for-people-who-know-just-enough-jquery-to-get-by-2019-version-28a4b4316d1a'>An Introduction to React in 2019 (For People Who Know Just Enough jQuery To Get By)</a></li><li>Uncle Bob Martin: <a href='https://blog.cleancoder.com/uncle-bob/2019/08/22/WhyClojure.html'>Why Clojure?</a></li></ul></li><li>Some great videos:<ul><li>John Carmack: <a href='https://youtu.be/1PhArSujR_A'>Rewriting Wolfenstein 3D using functional programming techniques</a></li><li>Rich Hickey: <a href='https://www.infoq.com/presentations/Simple-Made-Easy/'>Simple Made Easy</a></li><li>Dr. Mihaly Csikszentmihalyi: <a href='https://www.ted.com/talks/mihaly_csikszentmihalyi_on_flow?language=en'>TED talk on the flow state</a></li><li>Brian Goetz: <a href='https://youtu.be/2y5Pv4yN0b0'>Stewardship of the Java ecosystem</a></li><li>Rafal Dittwald: <a href='https://youtu.be/vK1DazRK_a0'>Solving problems the Clojure way</a></li><li>Bruce Hauman: <a href='https://youtu.be/j-kj2qwJa_E'>Talking about figwheel for Clojurescript development</a></li><li>Sean Corfield: <a href='https://www.youtube.com/embed/UFY2rd05W2g'>Using the REPL to debug a problem in core.memoize</a></li><li>Tiago Luchini: <a href='https://youtu.be/EDojA_fahvM'>Writing declarative domain models</a></li><li>David Nolen: <a href='https://www.youtube.com/watch?v=77b47P8EpfA'>Rethinking Identity</a></li></ul></li><li>Some great books:<ul><li>Michael Nygard: <code>Release it!</code></li><li>Chas Emerick, Brian Carper, Christophe Grand: <code>Clojure Programming</code></li><li>Russ Olsen: <code>Getting Clojure</code></li><li>Brian Goetz: <code>Java Concurrency in Practice</code></li><li>Martin Fowler: <code>Refactoring: Improving the design of existing code</code></li><li>Dr. Mihaly Csikszentmihalyi: <code>Flow: The psychology of optimal experience</code></li><li>Daniel Higgenbottom: <code>Clojure for the brave and true</code></li><li>Carin Meier: <code>Living Clojure</code></li><li>Mark Schwartz: <code>Seat at the table: IT leadership in the age of agility</code></li></ul></li><li>Clojure tutorials:<ul><li>Eric Normand: <a href='https://purelyfunctional.tv'>Purely Functional</a></li><li>Arne Brasseur: <a href='https://lambdaisland.com'>Lambda Island</a></li></ul></li></ul><p></div> </div> </div></p>]]></content>
  </entry>
  <entry>
    <id>simulating-the-passport-seva-kendra.html</id>
    <link href="simulating-the-passport-seva-kendra.html"/>
    <title>Simulating the Passport Seva Kendra using Clojure</title>
    <updated>2018-12-15T19:56:00+00:00</updated>
    <content type="html"><![CDATA[<p><div class="ox-neuron-main"> <div class="ox-neuron-toc"> <div class="ox-neuron-toc-contents"> <div class="ox-neuron-toc-heading">Table of Contents</div> <div class="ox-neuron-toc-items"></p><ul><li><a href='#the-problem-statement'>The Problem Statement</a></li><li><a href='#representing-all-the-information-about-the-psk'>Representing all the information about the PSK</a></li><li><a href='#letting-people-into-the-psk-and-generating-token-numbers-for-them-dot'>Letting people into the PSK, and generating token numbers for them.</a></li><li><a href='#queuing-up-people-and-simulating-the-work-done-at-every-stage'>Queuing up people and simulating the work done at every stage</a></li><li><a href='#keeping-track-of-people-and-the-display-board'>Keeping track of people and the display board</a></li><li><a href='#processing-people-concurrently-across-all-open-counters'>Processing people concurrently across all open counters</a></li><li><a href='#tying-everything-together-the-main-function'>Tying everything together - the main function</a></li><li><a href='#with-me-so-far-some-thoughts'>With me so far? Some thoughts</a></li><li><a href='#can-we-see-the-problem'>Can we see the problem?</a></li><li><a href='#final-thoughts'>Final Thoughts</a></li><li><a href='#references'>References</a></div></div></div></li></ul><p><div class="ox-neuron-article"> <h1 class="ox-neuron-article-heading">Simulating the Passport Seva Kendra using Clojure</h1> <div class="ox-neuron-article-contents"> <i>Cross-posted from my post on the <a href='https://medium.com/helpshift-engineering/simulating-the-passport-seva-kendra-using-clojure-fd88c12dde8c'>Helpshift Engineering Blog</a></i></p><p>A year ago, I went to the Passport Seva Kendra (PSK) in Mundhwa, Pune to get my passport renewed. At the time, the government had revamped this process and made it a simple, step-in/step-out painless affair. Unfortunately for me, I hit an edge-case in the system and took much longer than expected to complete. I was there for close to 4 hours. I used this time to observe the behavior of the PSK and think about ways to improve the applicant experience. I thought it was an interesting problem to solve and write about.</p><p>Recently, my wife booked an appointment at the PSK to renew <span class="underline">her</span> passport and this provided the spark I needed to write about it. So here we are, a year later, talking about the passport renewal process at the PSK.</p><p><!&ndash;more&ndash;></p><h2 id="the-problem-statement">The Problem Statement</h2><p>Let me describe the process to you first.</p><ul><li>The PSK has appointment slots every 15 minutes, and there are ~25 people in each slot.</li><li>Once you enter the PSK, there are 4 to 6 counters to verify your documents.</li><li>On verification, you are assigned a unique token number. We'll talk about this in a bit.</li><li>Token numbers are displayed on an electronic display-board. The board indicates which counter the person should go to. You are to wait in the waiting area and look at the display. You will soon be scheduled against a counter, where a PSK employee will help you with that particular stage of the process.</li><li>There are 3 stages in the process. The first is 'Biometrics' (Stage A). At this counter, the PSK employee collects your fingerprints and takes your photo. Your online form is updated with this information. There are 36 counters serving this stage (A-1, A-2 ... A-36).</li><li>The second stage is 'Form Check' (Stage B). At this point, the PSK employee checks the details in your form. If he finds any problems, he will redirect you to the Corrections counter. During my visit, counters A-34, A-35 and A-36 were reserved for corrections. After corrections, you have to come back to this stage. There are 12 counters (B-1, B-2 ... B-12).</li><li>The final stage is 'Form Re-Check' (Stage C). At this point, the agent double-checks the work of the previous counters and takes your form. If there are any corrections you have to go back to the corrections counters and start again. Once the form is checked, your reissue request has been processed. You are free to leave the PSK and go home. There are 10 counters (C-1, C-2 ... C-10).</li><li>Coming back to the token numbers. These are of the form N-10, S-4 etc. The alphabet represents the applicant category. These categories are as follows:<ul><li><strong>Normal (represented by N):</strong> Most people fall into this category.</li><li><strong>Senior (represented by S):</strong> For people older than 60</li><li><strong>Tatkal (represented by T):</strong> For people who want speedy processing of their passport (and have paid extra for this benefit)</li><li><strong>Requiring Police Clearance (represented by P):</strong> People who need clearance from the police (probably because they have criminal records, or work in sensitive departments in the government).</li></ul></li><li>Categories other than 'Normal' have a higher priority when it comes to processing their applications. For the purposes of this post, I assume that P has the highest priority, followed by S, T and N.</li></ul><p><img src="./static/images/psk-renderkid.jpg" alt="" /></p><p>In the rest of this post, we'll build this system as described above, and see if we can fix the flaw in it. We will use Clojure to write the solution. Clojure's concurrency primitives are fantastic, and helped me model this system in an elegant and readable way. As we go along, I'll explain these primitives in brief. <a href='https://twitter.com/ericnormand'>Eric Normand</a> has written an excellent guide to <a href='https://purelyfunctional.tv/guide/clojure-concurrency/'>understanding concurrency primitives</a> in Clojure, and <a href='https://twitter.com/richhickey'>Rich Hickey</a> has a <a href='https://www.youtube.com/watch?v=nDAfZK8m5_8'>great talk about this</a> as well. I highly recommend both these resources to the interested reader. The focus of this post will be on using these tools to implement a non-trivial system.</p><h3 id="so-what-is-the-problem-with-the-system">So what is the problem with the system?</h3><p>First, let's get the flaw out of the way. The problem with this system is that <span class="underline">the applicant has no idea when he'll be scheduled with an agent</span>. He must keep staring at the display board. For example, if you are N-30 and stage A took a particularly long time for you, others have moved past you to the next stage (B and beyond). The display board may read that N-41, N-42 etc are at counters B-1, B-2 etc. However, this does not mean that N-30 will show up next. The display board may go all the way to N-60 before N-30 shows up. As there is no certainty about when your number will show up, you have no option but to continuously stare at the board. This gets really irritating after a while.</p><p>Here are some ways to deal with this problem:</p><ol><li>Instead of using simple queues between the stages, use a priority queue. This means that even if N-30 took a long time on stage A, and the board had moved on to N-40s and above for stage B, as soon as N-30 is done with stage A he will be moved to the top of the queue for B. In this way, the applicant can look at the board and always tell whether he'll be up next or not.</li><li>Generate new token numbers between each stage. This will give the applicant a clear idea of the number of people ahead of him at any given point in time.</li><li>Provide the person with a new display board, where he can enter his token and see where he is in the queue for his stage.</li></ol><p>We will see these in action in our simulation program.</p><h2 id="representing-all-the-information-about-the-psk">Representing all the information about the PSK</h2><p>Everything describing the behaviour of the PSK can be captured in code. For our simulation, the data looks like this:</p><pre><code class="lang-clojure">&#40;def stages
  &quot;The various stages in the PSK, and transition from one stage to the other.

  - `processing-time-range` represents the amount of time spent at the
  counter in this stage &#40;in mins&#41;.
  - `next` represents the next stage for the person.
  - `counters` represent the number of counters/agents serving this stage.&quot;

  ;; Actual Values:
  ;; 4 Doc verification Counters
  ;; 33 counters for Biometrics
  ;; 12 for form checking
  ;; 10 for final checking
  ;; 3 for corrections
  ;; Using different values here so that the display board is
  ;; human-readable.

  {::enter {:next ::doc-verification}
   ::doc-verification {:next ::biometrics
                       :counters 10
                       :display-str &quot;0-&quot;
                       :processing-time-range &#91;1 5&#93;}
   ::biometrics {:next ::form-check
                 :counters 4
                 :display-str &quot;A-&quot;
                 :processing-time-range &#91;3 15&#93;}
   ::form-check {:next ::final-check
                 :counters 3
                 :display-str &quot;B-&quot;
                 :processing-time-range &#91;2 4&#93;
                 :failure ::corrections}
   ::final-check {:next ::exit
                  :counters 2
                  :display-str &quot;C-&quot;
                  :processing-time-range &#91;2 4&#93;}
   ::corrections {:next ::form-check
                  :counters 1
                  :display-str &quot;D-&quot;
                  :processing-time-range &#91;5 15&#93;}}&#41;

&#40;def waiting-room-capacity 500&#41; ; max number of waiting people

&#40;def total-capacity
  &quot;number of people that can be in the PSK at max&quot;
  &#40;apply + waiting-room-capacity &#40;keep :counters &#40;vals stages&#41;&#41;&#41;&#41;

&#40;def processing-batch-size
  &quot;no of people entering the center at one time.&quot;
  25&#41;

&#40;def new-batch-in-mins
  &quot;time between one batch and the next&quot;
  15&#41;

&#40;def stage-status
  &quot;For the given stage, the map of possible states that a person can be
  in.&quot;
  &#91;;; Person is in the waiting area, looking at the display to see
   ;; when he's called to a counter.
   ::waiting
   ;; Counter is assigned to the person
   ::in-process
   ;; Person is done with the counter and heading to the next stage.
   ::done&#93;&#41;
</code></pre><p>We use a simple map - <code>stages</code> - to represent all the stages in the PSK, the number of counters per stage, the amount of time per stage and the next stage after this one. A person is either waiting (looking at the display board), or is at a counter, or is done with a stage (<code>done</code> triggers a move to the next stage). From the point of view of the person, he is either waiting or at a counter.</p><h2 id="letting-people-into-the-psk-and-generating-token-numbers-for-them-dot">Letting people into the PSK, and generating token numbers for them.</h2><p>The first thing we will build is the token generator, and we'll use the most intuitive Clojure concurrency primitive for this: the <code>atom</code>.</p><h3 id="clojure-concurrency-primitive-atoms">Clojure Concurrency Primitive - Atoms</h3><p>Atoms are useful when reading / writing a single piece of data (potentially across multiple threads). This is the common case for shared resources and atoms are what I've used in most of the concurrency code I've written.</p><pre><code class="lang-clojure">&#40;def token-generator
  &quot;Give the next token number to the applicant.&quot;
  &#40;atom {:normal 0
         :senior 0
         :tatkal 0
         :police-clearance 0}&#41;&#41;

;; Use the token generator to get the next token as follows:
&#40;comment
  &#40;get &#40;swap! token-generator
              update
              person-type
              inc&#41;
       person-type&#41;&#41;
;; swap! is a way to atomically change the value held by the atom.
;; This does an internal compare and set operation, and thus the function
;; passed in to manipulate the value - in this case update - may be
;; called multiple times. This function should be free of side effects.
</code></pre><p>Clojure provides something more powerful - the <code>ref</code> - when you want to deal with multiple pieces of data that change together. We'll see it in action in the following sections.</p><p>If we choose some weights to represent the probability of an applicant belonging to a certain category, we can write some code to randomly generate applicants. The relevant code is <a href='https://gist.github.com/vedang/969a726e1f49f5fc550268a22c4e4b0d#file-psk-clj-L87-L131'>here</a>. We now have a way to assign increasing token numbers to each new person entering the PSK.</p><h3 id="clojure-concurrency-primitive-futures">Clojure Concurrency Primitive - Futures</h3><p>We'll use another Clojure concurrency primitive - a <code>future</code> - to continuously move people into the PSK. A future object invokes the body provided to it in a different thread.</p><p>In this case, we are starting an endless loop in a new thread. This code creates some people (representing people entering the PSK), sleeps for a bit, then repeats. We'll use our handy tool - an atom - to control when to stop the loop:</p><pre><code class="lang-clojure">&#40;def working-hours?
  &quot;Am I working right now?&quot;
  &#40;atom false&#41;&#41;

&#40;defn let-people-through
  &quot;Send people into the PSK in batches as defined by
  `processing-batch-size` and `new-batch-in-mins`. Note that in our
  code we use seconds to represent minutes.&quot;
  &#91;active-applicants done-applicants&#93;
  &#40;future
    &#40;loop &#91;&#93;
      &#40;if @working-hours?
       &#40;do
         ;; let new people through
         ;; &lt;logic goes here&gt; ...
         ;; then sleep for a while
         &#40;Thread/sleep &#40;&#42; 1000 new-batch-in-mins&#41;&#41;
         ;; repeat
         &#40;recur&#41;&#41;

       &#40;ctl/info &quot;&#91;Entry&#93; Working hours are over! Closing Shop! Come back later!&quot;&#41;&#41;&#41;&#41;&#41;
</code></pre><h2 id="queuing-up-people-and-simulating-the-work-done-at-every-stage">Queuing up people and simulating the work done at every stage</h2><p>Now that people are coming into the PSK, we need a way to queue them up between stages. We also want to write a simulation for the work done at every counter. As described in the problem statement, the PSK is using simple FIFO queues between each stage. We will use the <code>LinkedBlockingQueue</code> data structure to represent these. This data structure is provided by the battle-tested <code>java.util.concurrent</code> package. Dropping down to Java when needed is a bonus Clojure superpower!</p><pre><code class="lang-clojure">&#40;defn create-kendra-queues
  &quot;Given the counter-types / `stages` in the kendra, create the
  appropriate queues.&quot;
  &#91;kendra-stages q-capacity&#93;
  &#40;let &#91;queues-we-need &#40;-&gt; kendra-stages
                           keys
                           set
                           ;; Remove the stages where no queue of
                           ;; people is needed.
                           &#40;disj ::enter ::exit&#41;&#41;&#93;
    &#40;reduce &#40;fn &#91;m s&#93;
              &#40;assoc m
                     s &#40;LinkedBlockingQueue. q-capacity&#41;&#41;&#41;
            {}
            queues-we-need&#41;&#41;&#41;
</code></pre><p>Work at the counter involves the following:</p><ol><li>Pick the next person in the queue.</li><li>Call him to the counter by displaying his token number on the display.</li><li>Process the person, do the work.</li><li>Mark this stage as done. This will move him into the next queue.</li></ol><p>We can represent this in code as follows:</p><pre><code class="lang-clojure { hl_lines=["7-13"] }">&#40;defn process-applicant
  &quot;Get a person from the queue. Process this person as per the rules
  of the counter.&quot;
  &#91;psk-agent my-queue notice-board&#93;
  &#40;if @working-hours?

    &#40;if-let &#91;person &#40;.poll my-queue 1 java.util.concurrent.TimeUnit/SECONDS&#41;&#93;
      &#40;let &#91;stage &#40;:type psk-agent&#41;
            stage-config &#40;:config psk-agent&#41;&#93;

        &#40;call-person-to-counter stage notice-board psk-agent person&#41;
        &#40;process-person stage stage-config psk-agent @person&#41;
        &#40;mark-processing-as-complete stage notice-board psk-agent person&#41;

        &#40;send-off &#42;agent&#42; process-applicant my-queue notice-board&#41;
        &#40;assoc psk-agent :last-processed &#40;person-representation @person&#41;&#41;&#41;

      &#40;do &#40;send-off &#42;agent&#42; process-applicant my-queue notice-board&#41;
          psk-agent&#41;&#41;

    &#40;ctl/info &#40;format &quot;&#91;Agent: %s&#93; Working hours are over! Closing Shop! Come back later!&quot;
                      &#40;agent-representation psk-agent&#41;&#41;&#41;&#41;&#41;
</code></pre><p>As we saw previously, we control the running of the code using the <code>working-hours?</code> atom. We're seeing something new here - the <code>send-off</code> function used with Clojure Agents. Ignore this for the time being, we'll come to an explanation of this after seeing refs and transactions.</p><h2 id="keeping-track-of-people-and-the-display-board">Keeping track of people and the display board</h2><p>The tough part of this project is to keep track of the changes to each person's current state and the display board at every instant. These two views should always be consistent as multiple people are concurrently processed at different stages. Clojure makes this delightfully easy with refs and transactions.</p><h3 id="clojure-concurrency-primitive-refs&ndash;and-transactions">Clojure Concurrency Primitive - Refs (and transactions)</h3><p>Refs can be thought of as permanent pointers to mutable storage locations. The stored values can be safely changed - all together or none at all - using the functions <code>alter</code>, <code>ref-set</code> and <code>commute</code> within transactions. Clojure implements a Software Transactional Memory system<a href='#fn-1' id='fnref1'><sup>1</sup></a> and gives us A,C, and I of the famous ACID properties<a href='#fn-2' id='fnref2'><sup>2</sup></a>. (Since it's in-mem there is no Durability). Using these transactions in code will be familiar to anyone with experience of using DB transactions.</p><p>In practice, updating values looks like this:</p><pre><code class="lang-clojure">&#40;defn- call-person-to-counter
  &quot;Announce that person should come to the processing counter. Takes
  `person` and `notice-board` refs, performs a transactional update.&quot;
  &#91;stage notice-board psk-agent person&#93;
  &#40;dosync
   &#40;alter person
          assoc
          :stage stage
          :stage-status ::in-process
          :psk-agent &#40;agent-representation psk-agent&#41;&#41;
   &#40;store-stage-change person stage ::in-process&#41;
   &#40;alter notice-board
          assoc
          &#40;person-representation @person&#41;
          &#40;agent-representation psk-agent&#41;&#41;&#41;&#41;
</code></pre><p>Look Ma, no locks! This is much simpler, in my opinion, than thinking about which lock to take around which piece of data. Let's also check out the <code>store-state-change</code> function in the code above. This is a small data-collection function I wrote to calculate statistics about how much time each person takes in each stage.</p><pre><code class="lang-clojure">&#40;defn- store-stage-change
  &quot;For the given `Person` ref, store the change to their stage for later analysis.&quot;
  &#40;&#91;person new-stage new-status&#93;
   &#40;store-stage-change person new-stage new-status &#40;ct/now&#41;&#41;&#41;
  &#40;&#91;person new-stage new-status time-instant&#93;
   &#40;let &#91;stage-log &#40;-&gt;StageHistory new-stage new-status time-instant&#41;&#93;
     &#40;dosync
      &#40;alter person
             update
             :stage-history
             conj
             stage-log&#41;&#41;&#41;&#41;&#41;
</code></pre><p>Writing this function is simple: we know we want to modify an existing person, so we wrap it in a transaction. The calling code happens to already be in a transaction, but Clojure will deal with this correctly and collapse all the work into a single transaction. From our point of view, we know that anytime this function is called, it is going to safely and permanently modify the person and store the stage-change in it.</p><h2 id="processing-people-concurrently-across-all-open-counters">Processing people concurrently across all open counters</h2><p>The final piece of the puzzle is concurrently processing people on all the available counters. This is straightforward to do against a thread-pool, but Clojure provides another tool we can use: the <code>agent</code> .</p><h3 id="clojure-concurrency-primitive-agents">Clojure Concurrency Primitive - Agents</h3><p>Agents are another way to access/change mutable state, but they do this in an asynchronous manner. The functions <code>send</code> and <code>send-off</code> apply actions (functions) to the value held by the agent. The return value of the action becomes the new value of the agent. However, these actions execute in a different thread asynchronously. Clojure also guarantees execution in the order of submission. The value of the agent is inspectable at all times.</p><p>In our case, this allows us to represent processing counters as agents. The state of the agent is simply an identifier for it. Under the hood, each agent is spawning a thread from a thread-pool and executing a function. This function pulls the next person from the queue supplied to it, processes him, and sends another action to the current agent. We saw this function already, but let me post it again for clarity:</p><pre><code class="lang-clojure { hl_lines=["15-16","18-19"] }">&#40;defn process-applicant
  &quot;Get a person from the queue. Process this person as per the rules
  of the counter.&quot;
  &#91;psk-agent my-queue notice-board&#93;
  &#40;if @working-hours?

    &#40;if-let &#91;person &#40;.poll my-queue 1 java.util.concurrent.TimeUnit/SECONDS&#41;&#93;
      &#40;let &#91;stage &#40;:type psk-agent&#41;
            stage-config &#40;:config psk-agent&#41;&#93;

        &#40;call-person-to-counter stage notice-board psk-agent person&#41;
        &#40;process-person stage stage-config psk-agent @person&#41;
        &#40;mark-processing-as-complete stage notice-board psk-agent person&#41;

        &#40;send-off &#42;agent&#42; process-applicant my-queue notice-board&#41;
        &#40;assoc psk-agent :last-processed &#40;person-representation @person&#41;&#41;&#41;

      &#40;do &#40;send-off &#42;agent&#42; process-applicant my-queue notice-board&#41;
          psk-agent&#41;&#41;

    &#40;ctl/info &#40;format &quot;&#91;Agent: %s&#93; Working hours are over! Closing Shop! Come back later!&quot;
                      &#40;agent-representation psk-agent&#41;&#41;&#41;&#41;&#41;
</code></pre><p>We create Agents as follows:</p><pre><code class="lang-clojure { hl_lines=["7-8"] }">&#40;defrecord PSKAgent
    &#91;id type config&#93;&#41;

&#40;defn- create-agents
  &quot;For the given `agent-type`, create the given `num` of agents.&quot;
  &#91;agent-type stage-config num&#93;
  &#40;map &#40;comp agent &#40;fn &#91;i&#93; &#40;PSKAgent. &#40;inc i&#41; agent-type stage-config&#41;&#41;&#41;
       &#40;range num&#41;&#41;&#41;

&#40;defn create-kendra-agents
  &quot;Given the `stages` and their config for the kendra, create the
  appropriate agents to work these counters.&quot;
  &#91;kendra-stages&#93;
  &#40;let &#91;stages-with-counters &#40;-&gt; kendra-stages
                                 keys
                                 set
                                 ;; Remove the stages where no counter
                                 ;; of agents is needed.
                                 &#40;disj ::enter ::exit&#41;&#41;&#93;
    &#40;mapcat &#40;fn &#91;s&#93;
              &#40;let &#91;config &#40;get kendra-stages s&#41;&#93;
                &#40;create-agents s config &#40;:counters config&#41;&#41;&#41;&#41;
            stages-with-counters&#41;&#41;&#41;
</code></pre><h2 id="tying-everything-together-the-main-function">Tying everything together - the main function</h2><p>We tie all the pieces of the code together in our main function <code>start-the-kendra!</code>. The comments explain what each step is doing, for those of you unfamiliar with Clojure syntax.</p><pre><code class="lang-clojure">&#40;defn start-the-kendra!
  &quot;Setup our Passport Seva Kendra.&quot;
  &#91;&#93;
  &#40;let &#91;;; Create queues for the various stages, returns a map of
        ;; stage-name -&gt; queue
        stage-&gt;queue &#40;create-kendra-queues stages total-capacity&#41;
        ;; Create all the agents
        list-of-agents &#40;create-kendra-agents stages&#41;
        ;; Create a display board for waiting members
        notice-board &#40;ref &#40;sorted-map&#41;&#41;
        ;; Track all the active applicants
        active-applicants &#40;ref &#91;&#93;&#41;
        ;; Track all the completed applicants &#40;for debugging /
        ;; historical data purpose&#41;
        done-applicants &#40;ref &#91;&#93;&#41;&#93;
    &#40;ctl/info &quot;&#91;PSK&#93; Welcome, today is a good day.&quot;&#41;
    ;; For each agent at each counter, start processing!
    &#40;doseq &#91;a list-of-agents&#93;
      ;; Get the stage this agent is working at, and the queue of
      ;; people for that stage.
      &#40;let &#91;s &#40;:type @a&#41;
            q &#40;stage-&gt;queue s&#41;&#93;
        ;; Start processing people from the queue concurrently in
        ;; independent threads.
        &#40;send-off a process-applicant q notice-board&#41;&#41;&#41;
    ;; Start a continuous future for applicants to periodically enter
    ;; the PSK.
    &#40;let-people-through active-applicants done-applicants&#41;
    ;; Start a helper process to move people from one stage to the
    ;; other.
    &#40;move-people-through stages stage-&gt;queue active-applicants&#41;
    ;; Return the data. We'll use this to monitor our system.
    &#91;notice-board active-applicants done-applicants&#93;&#41;&#41;
</code></pre><p>We haven't seen the <code>move-people-through</code> helper function used above yet. This is a simple <code>future</code> which regularly sweeps through all the people and moves a person done with one stage to the other.</p><p>Originally, I wrote the code such that each agent was aware of an input queue as well as an output queue. The agent understood that he had to pick the next person from the input queue and move that person to the output queue on completion. I refactored that out to show that it is simple to add functions around existing concurrent code which modify existing shared resources. The code for <code>move-people-through</code> looks like this:</p><pre><code class="lang-clojure">&#40;defn move-people-through
  &quot;Review all the active applicants and move them into appropriate stages.&quot;
  &#91;kendra-stages stage-&gt;queue active-applicants&#93;
  &#40;future
    &#40;loop &#91;&#93;
      &#40;if @working-hours?

        &#40;let &#91;people @active-applicants&#93;
          &#40;doseq &#91;person &#40;-&gt;&gt; people
                              &#40;group-by &#40;comp :stage-status deref&#41;&#41;
                              ::done&#41;&#93;
            &#40;if &#40;= ::exit &#40;get-in kendra-stages &#91;&#40;:stage @person&#41; :next&#93;&#41;&#41;
              &#40;mark-applicant-process-as-complete person&#41;
              &#40;when-let &#91;next-stage &#40;get-in kendra-stages
                                            &#91;&#40;:stage @person&#41; :next&#93;&#41;&#93;
                &#40;move-applicant-to-next-stage stage-&gt;queue next-stage person&#41;&#41;&#41;&#41;

          &#40;Thread/sleep guide-people-to-next-stage-ms&#41;
          &#40;recur&#41;&#41;

        &#40;ctl/info &quot;&#91;Guide&#93; Working hours are over! Closing Shop! Come back later!&quot;&#41;&#41;&#41;&#41;&#41;
</code></pre><p>Both <code>mark-applicant-process-as-complete</code> and <code>move-applicant-to-next-stage</code> are tiny transactional updates to the person:</p><pre><code class="lang-clojure">&#40;defn- mark-applicant-process-as-complete
  &quot;Takes a `person` ref object and marks its processing as complete.&quot;
  &#91;person&#93;
  &#40;let &#91;time-instant &#40;ct/now&#41;&#93;
    &#40;dosync
     &#40;alter person
            assoc
            :stage ::exit
            :exit-time time-instant
            :total-time &#40;-&gt; @person
                            :enter-time
                            &#40;ct/interval time-instant&#41;
                            ct/in-seconds&#41;&#41;
     &#40;store-stage-change person ::exit ::done time-instant&#41;&#41;&#41;&#41;

&#40;defn- move-applicant-to-next-stage
  &quot;Given a `person` ref and the next stage they should go to, move
  them to the stage. Does a transactional update.&quot;
  &#91;stage-&gt;queue next-stage person&#93;
  &#40;dosync
   &#40;alter person
          assoc
          :stage next-stage
          :stage-status ::waiting&#41;
   &#40;store-stage-change person next-stage ::waiting&#41;&#41;
  &#40;.put &#40;stage-&gt;queue next-stage&#41; person&#41;&#41;
</code></pre><p>I also added a book-keeping function when letting people into the PSK. This function removes completed applicants from the list of active applicants. This frees up PSK capacity. I also move this data to a different list, because it's fun to go through it and look for interesting insights.</p><pre><code class="lang-clojure { hl_lines=["17-18"] }">&#40;defn- book-keeping-for-applicants
  &quot;Remove all applicants who are completely done from
  `active-applicants`. Store them in `done-applicants` for
  book-keeping.

  &#42;NOTE&#42; : Since this goes through the entire collection, it is slow.
  Hence we run it when sending in new batches of people.&quot;
  &#91;active-applicants done-applicants&#93;
  &#40;dosync
   &#40;let &#91;&#91;active-people done-people&#93; &#40;reduce &#40;fn &#91;&#91;aa da&#93; p&#93;
                                               &#40;if &#40;and &#40;= &#40;:stage @p&#41; ::exit&#41;
                                                        &#40;= &#40;:stage-status @p&#41; ::done&#41;&#41;
                                                 &#91;aa &#40;conj da p&#41;&#93;
                                                 &#91;&#40;conj aa p&#41; da&#93;&#41;&#41;
                                             &#91;&#91;&#93; &#91;&#93;&#93;
                                             @active-applicants&#41;&#93;
     &#40;ref-set active-applicants active-people&#41;
     &#40;alter done-applicants into done-people&#41;&#41;&#41;&#41;
</code></pre><p>Here we use the <code>ref-set</code> and <code>alter</code> functions to reset the value of active-applicants and modify the value of the done-applicants.</p><h2 id="with-me-so-far-some-thoughts">With me so far? Some thoughts</h2><ul><li>Clojure's concurrency primitives make it simple for me to <strong>think</strong> about this problem. I wrote the code like I would write a high-level pseudo description of the problem, and it worked just fine. I think this simplification is a huge benefit when dealing with concurrent code.</li><li>The ability to write and test small bits of concurrent code is a big win. It was simple for me to modify the original code and devise experiments around it.</li><li>We haven't really looked at what this looks like when it's running! Let's do that now!</li></ul><h2 id="can-we-see-the-problem">Can we see the problem?</h2><p>Let's run this system! We're setting up a small loop to display the board. We're running much fewer counters than the actual PSK. This is in order to make the display board consumable.</p><p><img src="./static/images/psk-run-1.gif" alt="" /></p><p>Things look good in this loop, the board looks predictable. The problem occurs when someone gets unlucky at one stage, and spends much more time there than the average person. Let's repeat the run by marking someone as unlucky, and by increasing the number of counters processing earlier stages (which matches with reality)</p><pre><code class="lang-clojure { hl_lines=["1-3","10-14"] }">&#40;def unlucky-applicant?
  &quot;Introduce a little anarchy!&quot;
  &#40;atom #{&quot;N-3&quot; &quot;S-2&quot;}&#41;&#41;

&#40;defn- process-person
  &quot;Do the work for processing the given person. Takes a `person`
  object and not a ref.&quot;
  &#91;stage stage-config psk-agent person&#93;
  &#40;let &#91;processing-time&#42; &#40;get-processing-time-for-stage stage-config&#41;
        processing-time &#40;if &#40;@unlucky-applicant? &#40;person-representation person&#41;&#41;
                          ;; You will need more time because the gods
                          ;; are against you.
                          &#40;&#42; 10 processing-time&#42;&#41;
                          processing-time&#42;&#41;&#93;
    &#40;Thread/sleep processing-time&#41;&#41;&#41;
</code></pre><p>Here is what this looks like:</p><p><img src="./static/images/psk-run-2.gif" alt="" /></p><p>As you can see, there are a number of people ahead of N-3 by the time he's done with stage 0. N-40s are being processed in stage 0 at this point in time. He has no idea where he is in the queue of people, and must keep staring at the display board at all times.</p><p>I will speak briefly about the three solutions that we initially proposed.</p><h3 id="solution-1-use-priority-queues">Solution 1: Use priority queues</h3><p>Using priority queues between each stage solves the problem of the applicant not knowing when he is next. However, there are two points to think about:</p><ol><li>The priority queue solves the problem within a given category, but not across categories. You know that you are the next N- category person at counter B, but you don't know when that will be because of all the S/T/P category people that will be served first.</li><li>A potential drawback of this may be: if a certain set of applicants are always slow at each stage, then in this model they will bring down the average number of people who will be served by the PSK (since we will prioritize serving them over people who have moved ahead of them).</li></ol><p>Making the change to use priority queues in our code is trivial. We go back to <code>java.util.concurrent</code> and swap out our <code>LinkedBlockingQueue</code> in favor of a <code>PriorityBlockingQueue</code>. Now all we have to do is provide a comparator function. The code for this is <a href='https://gist.github.com/vedang/969a726e1f49f5fc550268a22c4e4b0d#file-psk-clj-L393-L420'>here</a> We can also generate timing samples across people through repeated runs of the program. This will give us an idea of whether the average processing time is affected by using a Priority Queue or not.</p><h3 id="solution-2-new-token-numbers-per-stage">Solution 2: New token numbers per stage</h3><p>Using new token numbers solves the problem elegantly. This is probably not used because of the logistical difficulty of handing out new tokens to applicants again and again. In the real world, I'm sure that this process may cause confusion if not carefully designed. In our system, we already have a perfectly good way of getting the next token number - our atomic token generator. Implementing this solution is straight-forward and left as an exercise for the reader! (This blog post is already quite lengthy!)</p><h3 id="solution-3-where-am-i-estimated-wait-time">Solution 3: "Where am I?" Estimated Wait Time</h3><p>Another way the PSK can help the applicants is by providing a separate self-serve display. The applicant enters his token number and gets to see how many people are ahead of him for the given stage. Both <code>LinkedBlockingQueue</code> as well as <code>PriorityBlockingQueue</code> provide a <code>toArray</code> function which returns all the elements of the queue in order.</p><p>As we are tracking the time each person takes at each stage, we can also predict the estimated amount of time this person would have to wait. This could be an entire blog-post in itself<a href='#fn-3' id='fnref3'><sup>3</sup></a>.</p><p>I leave this as an exercise for the reader :)</p><h2 id="final-thoughts">Final Thoughts</h2><p>The complete code for this exercise can be found <a href='https://gist.github.com/vedang/969a726e1f49f5fc550268a22c4e4b0d'>here</a>. The <a href='https://gist.github.com/vedang/969a726e1f49f5fc550268a22c4e4b0d#file-psk-clj-L530-L545'>comment block</a> at the end of the gist explains how to run the program against a Clojure REPL. Note that this is not a trivial simulation of the PSK, I believe that the entire code can be actually used by them with a small set of changes. A list of things that we have not implemented:</p><ol><li>In the real world, we'd need to store each person's information in a DB along the way. Since the in-mem structures are guaranteed to be consistent, this is something we can achieve by periodically reading information about all applicants and committing it to the DB (similar to how <code>book-keeping-for-applicants</code> works).</li><li>We haven't implemented the error and corrections flow. Failure to pass a stage can be represented as another state (say <code>::error</code>). The <code>process-applicant</code> code will identify success/failure of the stage and set the appropriate state. <code>move-people-through</code> would need minor changes to deal with this. I leave this as an exercise for the reader.</li><li>In the real world, we'd need to build inputs for a real PSK employee to inform us that processing is done. This is nothing but a loop inside <code>process-applicant</code> which checks the DB to see if the work is done.</li></ol><p>I'd love to hear feedback about this post. Is there a better way to implement this? Tell me. Am I missing use-cases of the PSK and implementing a solution to a much simpler problem? Do tell! There may be drawbacks to solutions I've proposed that I cannot see, and there may be valid reasons the system is built the way it is. I'd love to understand the real-world problems that I've missed.</p><p>If you're interested in working with Clojure, on problems like Estimated Wait Time, <a href='https://jobs.lever.co/helpshift/'>we're hiring</a>! Send us an email at <a href='mailto:jobs@helpshift.com'>jobs@helpshift.com</a>.</p><p><i>A big thank you to the following people for reviewing initial drafts of this post: Kapil Reddy, Kiran Kulkarni, Mourjo Sen, Suvrat Apte, Dinesh Chhatani.</i></p><p><i>A big thank you to <a href='https://twitter.com/renderkid'>Bhargava Chowdary</a> for creating the illustration of the PSK.</i></p><h2 id="references">References</h2><ul><li>Eric Normand's post explaining all Clojure Concurrency primitives: <a href="https://purelyfunctional.tv/guide/clojure-concurrency/">https://purelyfunctional.tv/guide/clojure-concurrency/</a></li><li>Rich Hickey's talk on Clojure Concurrency: <a href="https://www.youtube.com/watch?v=nDAfZK8m5_8">https://www.youtube.com/watch?v=nDAfZK8m5_8</a></li><li>Atoms: <a href="https://clojure.org/reference/atoms">https://clojure.org/reference/atoms</a></li><li>Refs: <a href="https://clojure.org/reference/refs">https://clojure.org/reference/refs</a></li><li>Futures: <a href="https://clojuredocs.org/clojure.core/future">https://clojuredocs.org/clojure.core/future</a></li><li>Agents: <a href="https://clojure.org/reference/agents">https://clojure.org/reference/agents</a></li></ul><p></div> </div> <div class="ox-neuron-footnotes"> <div class="ox-neuron-footnotes-contents"></p></div></div></div><ol class='footnotes'><li id='fn-1'>STM: <a href="http://en.wikipedia.org/wiki/Software_transactional_memory">http://en.wikipedia.org/wiki/Software_transactional_memory</a><a href='#fnref1'>&#8617;</a></li><li id='fn-2'>ACID: <a href="https://en.wikipedia.org/wiki/ACID_(computer_science)">https://en.wikipedia.org/wiki/ACID_(computer_science)</a><a href='#fnref2'>&#8617;</a></li><li id='fn-3'>Estimating wait-times: <a href="https://en.wikipedia.org/wiki/Queueing_theory">https://en.wikipedia.org/wiki/Queueing_theory</a><a href='#fnref3'>&#8617;</a></li></ol>]]></content>
  </entry>
  <entry>
    <id>composability-and-compojure.html</id>
    <link href="composability-and-compojure.html"/>
    <title>Composability and Compojure</title>
    <updated>2012-02-23T23:58:00+00:00</updated>
    <content type="html"><![CDATA[<p><div class="ox-neuron-main"> <div class="ox-neuron-article"> <h1 class="ox-neuron-article-heading">Composability and Compojure</h1> <div class="ox-neuron-article-contents"> <i>Caveat</i>: This post needs some rudimentary knowledge of Compojure. Compojure is a web framework for Clojure, and if you don't understand what that means, then you should probably head over to the <a href='https://github.com/weavejester/compojure/wiki'>Compojure docs</a>.</p><p>Compojure exposes us to a beautifully <span class="underline">composable</span> abstraction, and this post is an attempt to show why that is a great thing.</p><p><!&ndash;more&ndash;></p><p>In order to understand the Compojure framework, let us write a small <code>cello world</code> app. The code snippets in this post are a means to explain a concept, they may not work as-is. The full, working code is available at <a href='https://gist.github.com/1893532/'>this</a> gist. Okay then, let's get started.</p><p>Here is what the basic routes function would look like:</p><pre><code class="lang-clojure">&#40;cc/defroutes main-routes
  &#40;cc/GET &quot;/&quot; &#91;&#93; &#40;fn &#91;req&#93;
                   &#40;rur/response &quot;&lt;h1&gt;Cello World&lt;/h1&gt;&quot;&#41;&#41;&#41;
  &#40;cc/GET &quot;/bye/&quot; &#91;&#93; &#40;fn &#91;req&#93;
                       &#40;rur/response &quot;&lt;h1&gt;Goodbye World&lt;/h1&gt;&quot;&#41;&#41;&#41;
  &#40;route/not-found &quot;&lt;h1&gt;Page not found&lt;/h1&gt;&quot;&#41;&#41;
</code></pre><p>Compojure uses Ring to handle requests and responses. These terms (request/response) don't mean 'objects' (to those of you from the OOP world) of any kind, they are just hash-maps used to <span class="underline">represent</span> the idea. They are data, and as such, can be manipulated in any way we want. Ring has a simple philosophy: write functions which accept a request and return a response. Such functions are called <span class="underline">handlers</span>.</p><p>The <code>cc/GET</code> helper macro - and it's ilk - asks the user for a request-method (specified by the GET in the name <code>cc/GET</code>), a route (string representing uri), and a handler(H1). The macro becomes a handler (H2) which returns the result of <code>&#40;H1 req&#41;</code> if the route and the method of the incoming request match the specified route and request-method, otherwise it returns nil. This is our first introduction to composability in Compojure. We have a macro that takes a handler and gives us another handler. As long as we are dealing in handlers, composability allows us to ignore any implementation complexity.</p><p>The <code>cc/defroutes</code> macro takes a name and a list of handlers and returns a handler (H3) which runs all the handlers in the list on the request until one of them returns a non-nil value, else it returns nil. Finally, it binds the name to the handler so that we can call it. Simple, isn't it?</p><p>So if you think you've understood it so far, tell me if adding this route to our main routes will work or not:</p><pre><code class="lang-clojure">&#40;cc/GET &quot;/hello&#42;&quot; &#91;&#93; &#40;cc/defroutes hello-routes
                       &#40;cc/GET &quot;/hello/name/&quot; &#91;&#93;
                               &#40;fn &#91;req&#93;
                                 &#40;rur/response &quot;&lt;h1&gt;Cello Vedang&lt;/h1&gt;&quot;&#41;&#41;&#41;
                       &#40;cc/GET &quot;/hello/city/&quot; &#91;&#93;
                               &#40;fn &#91;req&#93;
                                 &#40;rur/response &quot;&lt;h1&gt;Cello from Pune!&lt;/h1&gt;&quot;&#41;&#41;&#41;&#41;&#41;
</code></pre><p>Well, yes! <code>cc/defroutes</code> gives us a handler<a href='#fn-1' id='fnref1'><sup>1</sup></a>, and that's really all <code>cc/GET</code> cares about!</p><p>Having an abstraction of this form allows us to do many things easily, knowing that stuff <span class="underline">just works</span>. For example, let us write some <span class="underline">middleware</span>. What is middleware? Middleware modifies the incoming request or outgoing response in some way that makes us happy. How does this fit into our abstraction? - As a function that takes a handler(H1) and, wait for it, returns another handler(H2). Boom! Confused? Here is what a middleware function looks like:</p><pre><code class="lang-clojure">&#40;defn verify-secret
  &quot;Verify that secret-key has been sent as a parameter s in the request&quot;
  &#91;handler&#93;
  &#40;fn &#91;request&#93;
    &#40;if &#40;= &quot;s=please&quot; &#40;:query-string request&#41;&#41;
      &#40;handler request&#41;
      {:status 403
       :body &quot;You don't know the secret word&quot;}&#41;&#41;&#41;
</code></pre><p>This function gets a handler(H1). It doesn't know or care what that handler is going to do to the request. It returns a new handler(H2) which does the following: it checks to see if the incoming request knows that the secret word s is "please". If it does, great. Execute H1 on the request and call it a day. Otherwise, return a nil - meaning the request in not valid. Now H2 could go through as many other middleware functions as we want, all of them agnostic of any other middleware functions. Each middleware will return a modified handler(H3, H4, ... Hn), and we will run the final handler on the request.</p><p>Here is what the final code would look like:</p><pre><code class="lang-clojure">;; Define some Hello routes
&#40;cc/defroutes hello-routes
  &#40;cc/GET &quot;/hello/name/&quot; &#91;&#93;
          &#40;fn &#91;req&#93;
            &#40;rur/response &quot;&lt;h1&gt;Cello Vedang&lt;/h1&gt;&quot;&#41;&#41;&#41;
  &#40;cc/GET &quot;/hello/city/&quot; &#91;&#93;
          &#40;fn &#91;req&#93;
            &#40;rur/response &quot;&lt;h1&gt;Cello from Pune!&lt;/h1&gt;&quot;&#41;&#41;&#41;&#41;

;; Our main routes function.
&#40;cc/defroutes main-routes&#42;
  &#40;cc/GET &quot;/&quot; &#91;&#93; &#40;fn &#91;req&#93;
                   &#40;rur/response &quot;&lt;h1&gt;Cello World&lt;/h1&gt;&quot;&#41;&#41;&#41;
  &#40;cc/GET &quot;/bye/&quot; &#91;&#93; &#40;fn &#91;req&#93;
                       &#40;rur/response &quot;&lt;h1&gt;Goodbye World&lt;/h1&gt;&quot;&#41;&#41;&#41;
  &#40;cc/GET &quot;/hello&#42;&quot; &#91;&#93; hello-routes&#41;
  &#40;route/not-found &quot;&lt;h1&gt;Page not found&lt;/h1&gt;&quot;&#41;&#41;

;; A middleware function
&#40;defn verify-secret
  &quot;Verify that secret-key has been sent as a parameter s in the request&quot;
  &#91;handler&#93;
  &#40;fn &#91;request&#93;
    &#40;if &#40;= &quot;s=please&quot; &#40;:query-string request&#41;&#41;
      &#40;handler request&#41;
      {:status 403
       :body &quot;You don't know the secret word&quot;}&#41;&#41;&#41;

;;; Wrap my main routes in middleware
&#40;def main-routes &#40;-&gt; #'main-routes&#42;
                     verify-secret&#41;&#41;

;;; Start app with main routes
&#40;run-jetty #'main-routes {:port port :join? false}&#41;
</code></pre><p><code>main-routes&#42;</code> is a handler which matches the incoming uris to ones we support, <code>verify-secret</code> will make sure that the incoming requests know the secret word. We can go a really long way with functions that take a request and return a response. Compojure gives us a great DSL to deal with the web. It's composability facilitates building elegant systems and frameworks.</p><h2 id="footnotes">Footnotes:</h2><p></div> </div> <div class="ox-neuron-footnotes"> <div class="ox-neuron-footnotes-contents"></p></div></div></div><ol class='footnotes'><li id='fn-1'>: Actually, we got lucky in this case. <code>cc/defroutes</code> is a macro. When we say <code>&#40;cc/defroutes name &amp; handlers&#41;</code> the code is replaced to become <code>&#40;def name handlerfn&#41;</code>. Luckily for us though, def returns the variable which was just defined, and it works out okay in the end. The aim was to show composability in action, not to espouse a coding style. Never do this in actual code.<a href='#fnref1'>&#8617;</a></li></ol>]]></content>
  </entry>
</feed>
