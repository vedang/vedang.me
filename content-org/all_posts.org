#+hugo_base_dir: ../
#+setupfile: ./setup.org
* Projects
  :PROPERTIES:
  :CATEGORY: projects
  :END:
** DONE I have questions about COVID-19                 :covid19:coronavirus:
   CLOSED: [2020-03-23 Mon 10:10]
   :PROPERTIES:
   :EXPORT_HUGO_BUNDLE: i-have-questions-about-covid19
   :EXPORT_FILE_NAME: index
   :EXPORT_OPTIONS: num:1
   :EXPORT_HUGO_SECTION: projects
   :EXPORT_HUGO_RESOURCES: :src "hs_corona.js"
   :END:
   :LOGBOOK:
   - State "DONE"       from "TODO"       [2020-03-23 Mon 10:10]
   - State "TODO"       from              [2020-03-23 Mon 09:57]
   :END:
This page is a demo page, built to showcase how we can use bots to
answer common questions that people have about COVID-19. This is a
great way for folks to get up-to-date information about the pandemic
while staying at home.

To get started, click on the chat widget on the bottom right corner of
the screen. Follow the instructions.

This bot is built on guidelines and bots published by the World Health
Organization and the Indian Govt. The official websites are:

World Health Organization:
https://www.who.int/emergencies/diseases/novel-coronavirus-2019/events-as-they-happen

The Indian Govt: https://www.mygov.in/covid-19

If you have any questions, comments or feedback on the bot, please
email me at vedang at helpshift dot com.
#+begin_export html
<script src="hs_corona.js"></script>
#+end_export
* Programming                                                  :@programming:
  :PROPERTIES:
  :EXPORT_HUGO_SECTION: blog
  :END:
** DRAFT Using Constraint Propagation to solve the team Oncall rotation :constraint_propagation:clojure:
   :PROPERTIES:
   :EXPORT_FILE_NAME: using-constraint-propagation-for-oncall-rotation
   :END:
   :LOGBOOK:
   - Note taken on [2020-03-25 Wed 23:09] \\
     - Original date: <2020-01-02 Thu>
   :END:
*** Notation
  - Weeks of the calendar are represented by numbers
    + 1 to 52 for every week
  - One run of the program produces one schedule, starting from the next week (after the last provided week in the input schedule)
  - Each person is represented by a map of properties:
    + "name": name of the person,
    + "id": a keyword representing the person,
    + "in-next-rotation?": will be true for people who are to be considered in the next rotation,
    + "prev-rotation-week": will be a number representing the week when the person was oncall. This can be empty for someone who was not present in the previous rotation but would be present in the next one.
    + "leaves": leaves planned by the person. Represented as an array of tuples, each tuple representing the week that the person is on leave, and whether this is a soft/hard constraint on the scheduling. If the person is on leave for longer than one day in the week, it becomes a hard constraint against scheduling. If the person is on leave for only one day in the week, it is a soft constraint.
  - The output schedule is map of person-id -> oncall week number
*** Hard constraints
  - A person cannot be oncall when they are on leave for more than one day in the given week.
*** Soft constraints
  - The next oncall rotation for any person should be as far away from their previous rotation as possible.
  - A person should not be oncall if they have even a single leave planned in the week.

** DONE Simulating the Passport Seva Kendra using Clojure :concurrency:clojure:
   CLOSED: [2018-12-15 Sat 19:56]
   :PROPERTIES:
   :EXPORT_HUGO_BUNDLE: simulating-the-passport-seva-kendra
   :EXPORT_FILE_NAME: index
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :toc true :featured_image "blog/simulating-the-passport-seva-kendra/psk-renderkid.jpg"
   :EXPORT_SUBTITLE: "Exploring concurrency primitives in Clojure"
   :END:
/Cross-posted from my post on the [[https://medium.com/helpshift-engineering/simulating-the-passport-seva-kendra-using-clojure-fd88c12dde8c][Helpshift Engineering Blog]]/

A year ago, I went to the Passport Seva Kendra (PSK) in Mundhwa, Pune
to get my passport renewed. At the time, the government had revamped
this process and made it a simple, step-in/step-out painless affair.
Unfortunately for me, I hit an edge-case in the system and took much
longer than expected to complete. I was there for close to 4 hours. I
used this time to observe the behavior of the PSK and think about
ways to improve the applicant experience. I thought it was an
interesting problem to solve and write about.

Recently, my wife booked an appointment at the PSK to renew _her_
passport and this provided the spark I needed to write about it. So
here we are, a year later, talking about the passport renewal process
at the PSK.

#+hugo: more

*** The Problem Statement
    Let me describe the process to you first.

    - The PSK has appointment slots every 15 minutes, and there are ~25
      people in each slot.
    - Once you enter the PSK, there are 4 to 6 counters to verify your
      documents.
    - On verification, you are assigned a unique token number. We'll
      talk about this in a bit.
    - Token numbers are displayed on an electronic display-board. The
      board indicates which counter the person should go to. You are to
      wait in the waiting area and look at the display. You will soon be
      scheduled against a counter, where a PSK employee will help you
      with that particular stage of the process.
    - There are 3 stages in the process. The first is 'Biometrics'
      (Stage A). At this counter, the PSK employee collects your
      fingerprints and takes your photo. Your online form is updated
      with this information. There are 36 counters serving this stage
      (A-1, A-2 ... A-36).
    - The second stage is 'Form Check' (Stage B). At this point, the
      PSK employee checks the details in your form. If he finds any problems,
      he will redirect you to the Corrections counter. During my visit,
      counters A-34, A-35 and A-36 were reserved for corrections. After
      corrections, you have to come back to this stage. There are 12
      counters (B-1, B-2 ... B-12).
    - The final stage is 'Form Re-Check' (Stage C). At this point, the
      agent double-checks the work of the previous counters and takes
      your form. If there are any corrections you have to go back to the
      corrections counters and start again. Once the form is checked,
      your reissue request has been processed. You are free to leave the
      PSK and go home. There are 10 counters (C-1, C-2 ... C-10).
    - Coming back to the token numbers. These are of the form N-10, S-4
      etc. The alphabet represents the applicant category. These
      categories are as follows:
      + Normal (represented by N) :: Most people fall into this
           category.
      + Senior (represented by S) :: For people older than 60
      + Tatkal (represented by T) :: For people who want speedy
           processing of their passport (and have paid extra for this
           benefit)
      + Requiring Police Clearance (represented by P) :: People who need
           clearance from the police (probably because they have
           criminal records, or work in sensitive departments in the
           government).
    - Categories other than 'Normal' have a higher priority when it
      comes to processing their applications. For the purposes of this
      post, I assume that P has the highest priority, followed by S, T
      and N.

    {{< figure src="psk-renderkid.jpg" alt="The workings of the Passport Seva Kendra. Illustration by Bhargava Chowdary (@renderkid)" >}}

    In the rest of this post, we'll build this system as described
    above, and see if we can fix the flaw in it. We will use Clojure to
    write the solution. Clojure's concurrency primitives are fantastic,
    and helped me model this system in an elegant and readable way. As
    we go along, I'll explain these primitives in brief. [[https://twitter.com/ericnormand][Eric Normand]]
    has written an excellent guide to [[https://purelyfunctional.tv/guide/clojure-concurrency/][understanding concurrency
    primitives]] in Clojure, and [[https://twitter.com/richhickey][Rich Hickey]] has a [[https://www.youtube.com/watch?v=nDAfZK8m5_8][great talk about this]]
    as well. I highly recommend both these resources to the interested
    reader. The focus of this post will be on using these tools to
    implement a non-trivial system.

**** So what is the problem with the system?
     First, let's get the flaw out of the way. The problem with this
     system is that _the applicant has no idea when he'll be scheduled
     with an agent_. He must keep staring at the display board. For
     example, if you are N-30 and stage A took a particularly long time
     for you, others have moved past you to the next stage (B and
     beyond). The display board may read that N-41, N-42 etc are at
     counters B-1, B-2 etc. However, this does not mean that N-30 will
     show up next. The display board may go all the way to N-60 before
     N-30 shows up. As there is no certainty about when your number will
     show up, you have no option but to continuously stare at the board.
     This gets really irritating after a while.

     Here are some ways to deal with this problem:

     1. Instead of using simple queues between the stages, use a
        priority queue. This means that even if N-30 took a long time on
        stage A, and the board had moved on to N-40s and above for stage
        B, as soon as N-30 is done with stage A he will be moved to the
        top of the queue for B. In this way, the applicant can look at
        the board and always tell whether he'll be up next or not.
     2. Generate new token numbers between each stage. This will give
        the applicant a clear idea of the number of people ahead of him
        at any given point in time.
     3. Provide the person with a new display board, where he can enter
        his token and see where he is in the queue for his stage.

     We will see these in action in our simulation program.

*** Representing all the information about the PSK
    Everything describing the behaviour of the PSK can be captured in
    code. For our simulation, the data looks like this:

  #+begin_src clojure
    (def stages
      "The various stages in the PSK, and transition from one stage to the other.

      - `processing-time-range` represents the amount of time spent at the
      counter in this stage (in mins).
      - `next` represents the next stage for the person.
      - `counters` represent the number of counters/agents serving this stage."

      ;; Actual Values:
      ;; 4 Doc verification Counters
      ;; 33 counters for Biometrics
      ;; 12 for form checking
      ;; 10 for final checking
      ;; 3 for corrections
      ;; Using different values here so that the display board is
      ;; human-readable.

      {::enter {:next ::doc-verification}
       ::doc-verification {:next ::biometrics
                           :counters 10
                           :display-str "0-"
                           :processing-time-range [1 5]}
       ::biometrics {:next ::form-check
                     :counters 4
                     :display-str "A-"
                     :processing-time-range [3 15]}
       ::form-check {:next ::final-check
                     :counters 3
                     :display-str "B-"
                     :processing-time-range [2 4]
                     :failure ::corrections}
       ::final-check {:next ::exit
                      :counters 2
                      :display-str "C-"
                      :processing-time-range [2 4]}
       ::corrections {:next ::form-check
                      :counters 1
                      :display-str "D-"
                      :processing-time-range [5 15]}})

    (def waiting-room-capacity 500) ; max number of waiting people

    (def total-capacity
      "number of people that can be in the PSK at max"
      (apply + waiting-room-capacity (keep :counters (vals stages))))

    (def processing-batch-size
      "no of people entering the center at one time."
      25)

    (def new-batch-in-mins
      "time between one batch and the next"
      15)

    (def stage-status
      "For the given stage, the map of possible states that a person can be
      in."
      [;; Person is in the waiting area, looking at the display to see
       ;; when he's called to a counter.
       ::waiting
       ;; Counter is assigned to the person
       ::in-process
       ;; Person is done with the counter and heading to the next stage.
       ::done])
  #+end_src

    We use a simple map - ~stages~ - to represent all the stages in the
    PSK, the number of counters per stage, the amount of time per stage
    and the next stage after this one. A person is either waiting
    (looking at the display board), or is at a counter, or is done with
    a stage (~done~ triggers a move to the next stage). From the point
    of view of the person, he is either waiting or at a counter.

*** Letting people into the PSK, and generating token numbers for them.
    The first thing we will build is the token generator, and we'll use
    the most intuitive Clojure concurrency primitive for this: the
    ~atom~.

**** Clojure Concurrency Primitive - Atoms
     Atoms are useful when reading / writing a single piece of data
     (potentially across multiple threads). This is the common case for
     shared resources and atoms are what I've used in most of the
     concurrency code I've written.

  #+begin_src clojure
    (def token-generator
      "Give the next token number to the applicant."
      (atom {:normal 0
             :senior 0
             :tatkal 0
             :police-clearance 0}))

    ;; Use the token generator to get the next token as follows:
    (comment
      (get (swap! token-generator
                  update
                  person-type
                  inc)
           person-type))
    ;; swap! is a way to atomically change the value held by the atom.
    ;; This does an internal compare and set operation, and thus the function
    ;; passed in to manipulate the value - in this case update - may be
    ;; called multiple times. This function should be free of side effects.
  #+end_src

    Clojure provides something more powerful - the ~ref~ - when you want
    to deal with multiple pieces of data that change together. We'll see
    it in action in the following sections.

    If we choose some weights to represent the probability of an
    applicant belonging to a certain category, we can write some code to
    randomly generate applicants. The relevant code is [[https://gist.github.com/vedang/969a726e1f49f5fc550268a22c4e4b0d#file-psk-clj-L87-L131][here]]. We now have
    a way to assign increasing token numbers to each new person entering
    the PSK.

**** Clojure Concurrency Primitive - Futures
     We'll use another Clojure concurrency primitive - a ~future~ - to
     continuously move people into the PSK. A future object invokes the
     body provided to it in a different thread.

     In this case, we are starting an endless loop in a new thread. This
     code creates some people (representing people entering the PSK),
     sleeps for a bit, then repeats. We'll use our handy tool - an
     atom - to control when to stop the loop:

  #+begin_src clojure
    (def working-hours?
      "Am I working right now?"
      (atom false))

    (defn let-people-through
      "Send people into the PSK in batches as defined by
      `processing-batch-size` and `new-batch-in-mins`. Note that in our
      code we use seconds to represent minutes."
      [active-applicants done-applicants]
      (future
        (loop []
          (if @working-hours?
           (do
             ;; let new people through
             ;; <logic goes here> ...
             ;; then sleep for a while
             (Thread/sleep (* 1000 new-batch-in-mins))
             ;; repeat
             (recur))

           (ctl/info "[Entry] Working hours are over! Closing Shop! Come back later!")))))
  #+end_src

*** Queuing up people and simulating the work done at every stage
    Now that people are coming into the PSK, we need a way to queue them
    up between stages. We also want to write a simulation for the work
    done at every counter. As described in the problem statement, the
    PSK is using simple FIFO queues between each stage. We will use the
    ~LinkedBlockingQueue~ data structure to represent these. This data
    structure is provided by the battle-tested ~java.util.concurrent~
    package. Dropping down to Java when needed is a bonus Clojure
    superpower!

  #+begin_src clojure
    (defn create-kendra-queues
      "Given the counter-types / `stages` in the kendra, create the
      appropriate queues."
      [kendra-stages q-capacity]
      (let [queues-we-need (-> kendra-stages
                               keys
                               set
                               ;; Remove the stages where no queue of
                               ;; people is needed.
                               (disj ::enter ::exit))]
        (reduce (fn [m s]
                  (assoc m
                         s (LinkedBlockingQueue. q-capacity)))
                {}
                queues-we-need)))
  #+end_src

    Work at the counter involves the following:

    1. Pick the next person in the queue.
    2. Call him to the counter by displaying his token number on the
       display.
    3. Process the person, do the work.
    4. Mark this stage as done. This will move him into the next queue.

    We can represent this in code as follows:

  #+begin_src clojure :hl_lines 7-13
    (defn process-applicant
      "Get a person from the queue. Process this person as per the rules
      of the counter."
      [psk-agent my-queue notice-board]
      (if @working-hours?

        (if-let [person (.poll my-queue 1 java.util.concurrent.TimeUnit/SECONDS)]
          (let [stage (:type psk-agent)
                stage-config (:config psk-agent)]

            (call-person-to-counter stage notice-board psk-agent person)
            (process-person stage stage-config psk-agent @person)
            (mark-processing-as-complete stage notice-board psk-agent person)

            (send-off *agent* process-applicant my-queue notice-board)
            (assoc psk-agent :last-processed (person-representation @person)))

          (do (send-off *agent* process-applicant my-queue notice-board)
              psk-agent))

        (ctl/info (format "[Agent: %s] Working hours are over! Closing Shop! Come back later!"
                          (agent-representation psk-agent)))))
  #+end_src

    As we saw previously, we control the running of the code using the
    ~working-hours?~ atom. We're seeing something new here - the
    ~send-off~ function used with Clojure Agents. Ignore this for the
    time being, we'll come to an explanation of this after seeing refs
    and transactions.

*** Keeping track of people and the display board
    The tough part of this project is to keep track of the changes to
    each person's current state and the display board at every instant.
    These two views should always be consistent as multiple people are
    concurrently processed at different stages. Clojure makes this
    delightfully easy with refs and transactions.

**** Clojure Concurrency Primitive - Refs (and transactions)
     Refs can be thought of as permanent pointers to mutable storage
     locations. The stored values can be safely changed - all together
     or none at all - using the functions ~alter~, ~ref-set~ and
     ~commute~ within transactions. Clojure implements a Software
     Transactional Memory system[fn:1] and gives us A,C, and I of the
     famous ACID properties[fn:2]. (Since it's in-mem there is no
     Durability). Using these transactions in code will be familiar to
     anyone with experience of using DB transactions.

     In practice, updating values looks like this:
  #+begin_src clojure
    (defn- call-person-to-counter
      "Announce that person should come to the processing counter. Takes
      `person` and `notice-board` refs, performs a transactional update."
      [stage notice-board psk-agent person]
      (dosync
       (alter person
              assoc
              :stage stage
              :stage-status ::in-process
              :psk-agent (agent-representation psk-agent))
       (store-stage-change person stage ::in-process)
       (alter notice-board
              assoc
              (person-representation @person)
              (agent-representation psk-agent))))
  #+end_src

    Look Ma, no locks! This is much simpler, in my opinion, than
    thinking about which lock to take around which piece of data. Let's
    also check out the ~store-state-change~ function in the code above.
    This is a small data-collection function I wrote to calculate
    statistics about how much time each person takes in each stage.

  #+begin_src clojure
    (defn- store-stage-change
      "For the given `Person` ref, store the change to their stage for later analysis."
      ([person new-stage new-status]
       (store-stage-change person new-stage new-status (ct/now)))
      ([person new-stage new-status time-instant]
       (let [stage-log (->StageHistory new-stage new-status time-instant)]
         (dosync
          (alter person
                 update
                 :stage-history
                 conj
                 stage-log)))))
  #+end_src

    Writing this function is simple: we know we want to modify an
    existing person, so we wrap it in a transaction. The calling code
    happens to already be in a transaction, but Clojure will deal with
    this correctly and collapse all the work into a single transaction.
    From our point of view, we know that anytime this function is
    called, it is going to safely and permanently modify the person and
    store the stage-change in it.

*** Processing people concurrently across all open counters
    The final piece of the puzzle is concurrently processing people on
    all the available counters. This is straightforward to do against a
    thread-pool, but Clojure provides another tool we can use: the
    ~agent~ .

**** Clojure Concurrency Primitive - Agents
     Agents are another way to access/change mutable state, but they do
     this in an asynchronous manner. The functions ~send~ and ~send-off~
     apply actions (functions) to the value held by the agent. The
     return value of the action becomes the new value of the agent.
     However, these actions execute in a different thread
     asynchronously. Clojure also guarantees execution in the order of
     submission. The value of the agent is inspectable at all times.

     In our case, this allows us to represent processing counters as
     agents. The state of the agent is simply an identifier for it.
     Under the hood, each agent is spawning a thread from a thread-pool
     and executing a function. This function pulls the next person from
     the queue supplied to it, processes him, and sends another action
     to the current agent. We saw this function already, but let me post
     it again for clarity:

  #+begin_src clojure :hl_lines 15-16,18-19
    (defn process-applicant
      "Get a person from the queue. Process this person as per the rules
      of the counter."
      [psk-agent my-queue notice-board]
      (if @working-hours?

        (if-let [person (.poll my-queue 1 java.util.concurrent.TimeUnit/SECONDS)]
          (let [stage (:type psk-agent)
                stage-config (:config psk-agent)]

            (call-person-to-counter stage notice-board psk-agent person)
            (process-person stage stage-config psk-agent @person)
            (mark-processing-as-complete stage notice-board psk-agent person)

            (send-off *agent* process-applicant my-queue notice-board)
            (assoc psk-agent :last-processed (person-representation @person)))

          (do (send-off *agent* process-applicant my-queue notice-board)
              psk-agent))

        (ctl/info (format "[Agent: %s] Working hours are over! Closing Shop! Come back later!"
                          (agent-representation psk-agent)))))
  #+end_src

     We create Agents as follows:

  #+begin_src clojure :hl_lines 7-8
    (defrecord PSKAgent
        [id type config])

    (defn- create-agents
      "For the given `agent-type`, create the given `num` of agents."
      [agent-type stage-config num]
      (map (comp agent (fn [i] (PSKAgent. (inc i) agent-type stage-config)))
           (range num)))

    (defn create-kendra-agents
      "Given the `stages` and their config for the kendra, create the
      appropriate agents to work these counters."
      [kendra-stages]
      (let [stages-with-counters (-> kendra-stages
                                     keys
                                     set
                                     ;; Remove the stages where no counter
                                     ;; of agents is needed.
                                     (disj ::enter ::exit))]
        (mapcat (fn [s]
                  (let [config (get kendra-stages s)]
                    (create-agents s config (:counters config))))
                stages-with-counters)))
  #+end_src

*** Tying everything together - the main function
    We tie all the pieces of the code together in our main function
    ~start-the-kendra!~. The comments explain what each step is doing,
    for those of you unfamiliar with Clojure syntax.

  #+begin_src clojure
    (defn start-the-kendra!
      "Setup our Passport Seva Kendra."
      []
      (let [;; Create queues for the various stages, returns a map of
            ;; stage-name -> queue
            stage->queue (create-kendra-queues stages total-capacity)
            ;; Create all the agents
            list-of-agents (create-kendra-agents stages)
            ;; Create a display board for waiting members
            notice-board (ref (sorted-map))
            ;; Track all the active applicants
            active-applicants (ref [])
            ;; Track all the completed applicants (for debugging /
            ;; historical data purpose)
            done-applicants (ref [])]
        (ctl/info "[PSK] Welcome, today is a good day.")
        ;; For each agent at each counter, start processing!
        (doseq [a list-of-agents]
          ;; Get the stage this agent is working at, and the queue of
          ;; people for that stage.
          (let [s (:type @a)
                q (stage->queue s)]
            ;; Start processing people from the queue concurrently in
            ;; independent threads.
            (send-off a process-applicant q notice-board)))
        ;; Start a continuous future for applicants to periodically enter
        ;; the PSK.
        (let-people-through active-applicants done-applicants)
        ;; Start a helper process to move people from one stage to the
        ;; other.
        (move-people-through stages stage->queue active-applicants)
        ;; Return the data. We'll use this to monitor our system.
        [notice-board active-applicants done-applicants]))
  #+end_src

    We haven't seen the ~move-people-through~ helper function used above
    yet. This is a simple ~future~ which regularly sweeps through all
    the people and moves a person done with one stage to the other.

    Originally, I wrote the code such that each agent was aware of an
    input queue as well as an output queue. The agent understood that he
    had to pick the next person from the input queue and move that
    person to the output queue on completion. I refactored that out to
    show that it is simple to add functions around existing concurrent
    code which modify existing shared resources. The code for
    ~move-people-through~ looks like this:

  #+begin_src clojure
    (defn move-people-through
      "Review all the active applicants and move them into appropriate stages."
      [kendra-stages stage->queue active-applicants]
      (future
        (loop []
          (if @working-hours?

            (let [people @active-applicants]
              (doseq [person (->> people
                                  (group-by (comp :stage-status deref))
                                  ::done)]
                (if (= ::exit (get-in kendra-stages [(:stage @person) :next]))
                  (mark-applicant-process-as-complete person)
                  (when-let [next-stage (get-in kendra-stages
                                                [(:stage @person) :next])]
                    (move-applicant-to-next-stage stage->queue next-stage person))))

              (Thread/sleep guide-people-to-next-stage-ms)
              (recur))

            (ctl/info "[Guide] Working hours are over! Closing Shop! Come back later!")))))
  #+end_src

    Both ~mark-applicant-process-as-complete~ and
    ~move-applicant-to-next-stage~ are tiny transactional updates to the
    person:

  #+begin_src clojure
    (defn- mark-applicant-process-as-complete
      "Takes a `person` ref object and marks its processing as complete."
      [person]
      (let [time-instant (ct/now)]
        (dosync
         (alter person
                assoc
                :stage ::exit
                :exit-time time-instant
                :total-time (-> @person
                                :enter-time
                                (ct/interval time-instant)
                                ct/in-seconds))
         (store-stage-change person ::exit ::done time-instant))))

    (defn- move-applicant-to-next-stage
      "Given a `person` ref and the next stage they should go to, move
      them to the stage. Does a transactional update."
      [stage->queue next-stage person]
      (dosync
       (alter person
              assoc
              :stage next-stage
              :stage-status ::waiting)
       (store-stage-change person next-stage ::waiting))
      (.put (stage->queue next-stage) person))
  #+end_src

    I also added a book-keeping function when letting people into the
    PSK. This function removes completed applicants from the list of
    active applicants. This frees up PSK capacity. I also move this data
    to a different list, because it's fun to go through it and look for
    interesting insights.

  #+begin_src clojure :hl_lines 17-18
    (defn- book-keeping-for-applicants
      "Remove all applicants who are completely done from
      `active-applicants`. Store them in `done-applicants` for
      book-keeping.

      ,*NOTE* : Since this goes through the entire collection, it is slow.
      Hence we run it when sending in new batches of people."
      [active-applicants done-applicants]
      (dosync
       (let [[active-people done-people] (reduce (fn [[aa da] p]
                                                   (if (and (= (:stage @p) ::exit)
                                                            (= (:stage-status @p) ::done))
                                                     [aa (conj da p)]
                                                     [(conj aa p) da]))
                                                 [[] []]
                                                 @active-applicants)]
         (ref-set active-applicants active-people)
         (alter done-applicants into done-people))))
  #+end_src

    Here we use the ~ref-set~ and ~alter~ functions to reset the value
    of active-applicants and modify the value of the done-applicants.

*** With me so far? Some thoughts
    - Clojure's concurrency primitives make it simple for me to *think*
      about this problem. I wrote the code like I would write a
      high-level pseudo description of the problem, and it worked just
      fine. I think this simplification is a huge benefit when dealing
      with concurrent code.
    - The ability to write and test small bits of concurrent code is a
      big win. It was simple for me to modify the original code and
      devise experiments around it.
    - We haven't really looked at what this looks like when it's
      running! Let's do that now!

*** Can we see the problem?
    Let's run this system! We're setting up a small loop to display the
    board. We're running much fewer counters than the actual PSK. This
    is in order to make the display board consumable.

    {{< figure src="psk-run-1.gif" alt="A normal day at the Passport Seva Kendra" >}}

    Things look good in this loop, the board looks predictable. The
    problem occurs when someone gets unlucky at one stage, and spends
    much more time there than the average person. Let's repeat the run
    by marking someone as unlucky, and by increasing the number of
    counters processing earlier stages (which matches with reality)

  #+begin_src clojure :hl_lines 1-3,10-14
    (def unlucky-applicant?
      "Introduce a little anarchy!"
      (atom #{"N-3" "S-2"}))

    (defn- process-person
      "Do the work for processing the given person. Takes a `person`
      object and not a ref."
      [stage stage-config psk-agent person]
      (let [processing-time* (get-processing-time-for-stage stage-config)
            processing-time (if (@unlucky-applicant? (person-representation person))
                              ;; You will need more time because the gods
                              ;; are against you.
                              (* 10 processing-time*)
                              processing-time*)]
        (Thread/sleep processing-time)))
  #+end_src

    Here is what this looks like:

    {{< figure src="psk-run-2.gif" alt="N-3 is not having a good day." >}}

    As you can see, there are a number of people ahead of N-3 by the
    time he's done with stage 0. N-40s are being processed in stage 0 at
    this point in time. He has no idea where he is in the queue of
    people, and must keep staring at the display board at all times.

    I will speak briefly about the three solutions that we initially
    proposed.

**** Solution 1: Use priority queues
     Using priority queues between each stage solves the problem of the
     applicant not knowing when he is next. However, there are two
     points to think about:
     1. The priority queue solves the problem within a given category,
        but not across categories. You know that you are the next N-
        category person at counter B, but you don't know when that will
        be because of all the S/T/P category people that will be served
        first.
     2. A potential drawback of this may be: if a certain set of
        applicants are always slow at each stage, then in this model
        they will bring down the average number of people who will be
        served by the PSK (since we will prioritize serving them over
        people who have moved ahead of them).

     Making the change to use priority queues in our code is trivial. We
     go back to ~java.util.concurrent~ and swap out our
     ~LinkedBlockingQueue~ in favor of a ~PriorityBlockingQueue~. Now
     all we have to do is provide a comparator function. The code for
     this is [[https://gist.github.com/vedang/969a726e1f49f5fc550268a22c4e4b0d#file-psk-clj-L393-L420][here]] We can also generate timing samples across people
     through repeated runs of the program. This will give us an idea of
     whether the average processing time is affected by using a Priority
     Queue or not.

**** Solution 2: New token numbers per stage
     Using new token numbers solves the problem elegantly. This is
     probably not used because of the logistical difficulty of handing
     out new tokens to applicants again and again. In the real world,
     I'm sure that this process may cause confusion if not carefully
     designed. In our system, we already have a perfectly good way of
     getting the next token number - our atomic token generator.
     Implementing this solution is straight-forward and left as an
     exercise for the reader! (This blog post is already quite lengthy!)

**** Solution 3: "Where am I?" Estimated Wait Time
     Another way the PSK can help the applicants is by providing a
     separate self-serve display. The applicant enters his token number
     and gets to see how many people are ahead of him for the given
     stage. Both ~LinkedBlockingQueue~ as well as
     ~PriorityBlockingQueue~ provide a ~toArray~ function which returns
     all the elements of the queue in order.

     As we are tracking the time each person takes at each stage, we can
     also predict the estimated amount of time this person would have to
     wait. This could be an entire blog-post in itself[fn:3].

     I leave this as an exercise for the reader :)

*** Final Thoughts
    The complete code for this exercise can be found [[https://gist.github.com/vedang/969a726e1f49f5fc550268a22c4e4b0d][here]]. The [[https://gist.github.com/vedang/969a726e1f49f5fc550268a22c4e4b0d#file-psk-clj-L530-L545][comment
    block]] at the end of the gist explains how to run the program against
    a Clojure REPL. Note that this is not a trivial simulation of the
    PSK, I believe that the entire code can be actually used by them
    with a small set of changes. A list of things that we have not
    implemented:
    1. In the real world, we'd need to store each person's information
       in a DB along the way. Since the in-mem structures are guaranteed
       to be consistent, this is something we can achieve by
       periodically reading information about all applicants and
       committing it to the DB (similar to how
       ~book-keeping-for-applicants~ works).
    2. We haven't implemented the error and corrections flow. Failure to
       pass a stage can be represented as another state (say ~::error~).
       The ~process-applicant~ code will identify success/failure of the
       stage and set the appropriate state. ~move-people-through~ would
       need minor changes to deal with this. I leave this as an exercise
       for the reader.
    3. In the real world, we'd need to build inputs for a real PSK
       employee to inform us that processing is done. This is nothing
       but a loop inside ~process-applicant~ which checks the DB to see
       if the work is done.

    I'd love to hear feedback about this post. Is there a better way to
    implement this? Tell me. Am I missing use-cases of the PSK and
    implementing a solution to a much simpler problem? Do tell! There
    may be drawbacks to solutions I've proposed that I cannot see, and
    there may be valid reasons the system is built the way it is. I'd
    love to understand the real-world problems that I've missed.

    If you're interested in working with Clojure, on problems like
    Estimated Wait Time, [[https://jobs.lever.co/helpshift/][we're hiring]]! Send us an email at
    [[mailto:jobs@helpshift.com][jobs@helpshift.com]].

    /A big thank you to the following people for reviewing initial
    drafts of this post: Kapil Reddy, Kiran Kulkarni, Mourjo Sen, Suvrat
    Apte, Dinesh Chhatani./

    /A big thank you to [[https://twitter.com/renderkid][Bhargava Chowdary]] for creating the illustration
    of the PSK./

*** References

    - Eric Normand's post explaining all Clojure Concurrency primitives:
      [[https://purelyfunctional.tv/guide/clojure-concurrency/]]
    - Rich Hickey's talk on Clojure Concurrency:
      [[https://www.youtube.com/watch?v=nDAfZK8m5_8]]
    - Atoms: [[https://clojure.org/reference/atoms]]
    - Refs: [[https://clojure.org/reference/refs]]
    - Futures: [[https://clojuredocs.org/clojure.core/future]]
    - Agents: [[https://clojure.org/reference/agents]]

*** Footnotes

[fn:3] Estimating wait-times: [[https://en.wikipedia.org/wiki/Queueing_theory]]

[fn:2] ACID: [[https://en.wikipedia.org/wiki/ACID_(computer_science)]]

[fn:1] STM: [[http://en.wikipedia.org/wiki/Software_transactional_memory]]

#  LocalWords:  PSK Seva Clojure
** TODO Writing Flink Jobs in Clojure               :streaming:flink:clojure:
   :PROPERTIES:
   :EXPORT_SUBTITLE: "Figuring out the hoops you have to jump through to run Clojure code on Apache Flink"
   :EXPORT_FILE_NAME: flink-jobs-in-clojure
   :END:
   :LOGBOOK:
   - Note taken on [2020-03-25 Wed 22:59] \\
     - Original notes taken on <2017-09-02 Sat 19:58>
     - Brushed up on <2019-06-13 Thu>
   :END:
*** 4e3f68a * Add concrete type info to generic Flink interfaces
    Java to the rescue!

    Add a Java class to be a simple data-structure to hold our
    word-count data.

    Define an interface in Java which applies concrete types to generic
    Flink interfaces.

    Reify'ing this *now* has all the type information needed by Flink!
    Clojure code for the win, with a little help from Java.

*** b997c9c * Modify code to use a single reified object
    Since we are reifying the same interface, we might as well do it
    just once, and reuse that object in the various chained stages of
    the Flink pipeline

*** 8f7fcc0 * Convert the WriteIntoKafka example into Clojure
    This one has an important and slightly discouraging discovery. We
    implement our own source here which keeps returning new strings
    every second. We need to implement the `SourceFunction` interface
    for this.

    Initially, I thought that the previous approach of implementing a
    concrete Interface which extends `SourceFunction<String>` would be
    enough, but this is not true. This is because of the way that the
    two methods of the `SourceFunction` Interface interact with each
    other. The `run` method starts a possible infinite loop, and the
    `cancel` method stops the loop started by the `run` method. This
    requires us to mutate state held within the Class, but without
    using any of the Clojure state management methods like atom, ref
    etc. This is because these are not `Serializable`. I don't know how
    to do this from Clojure, and I'm 99% sure that it is not possible.

    Due to this, I had to write a class in Java which implemented the
    `SourceFunction` interface.

*** bab6c3a * Convert the socket-window wordcounter to a defrec
    Using a ~defrecord~ allows me to specify the ~:load-ns~ option,
    which is very useful. It ensures that the entire namespace where
    the defrecord is defined gets loaded when I use the record anywhere
    in my code. This helps avoid errors like:
    + Attempting to call unbound fn:
      #'poclink.event-stream-processor/json-str->event
* Tools                                                              :@tools:
  :PROPERTIES:
  :EXPORT_HUGO_SECTION: blog
  :END:
** DONE Problems in my brand new System76 Oryx Pro laptop :laptops:system76:popos:linux:
   CLOSED: [2019-05-31 Fri 22:51]
   :PROPERTIES:
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :toc true
   :EXPORT_FILE_NAME: problems-in-system76-oryx-pro
   :END:
*** *Important Note*
  I'm enjoying using a Linux laptop after years of development on the
  Macbook, and this post is more a list of issues I personally faced
  on moving to Linux after 7 years of development on the Macbook. I'd
  written a similar thing when I'd moved to the Macbook for the first
  time. Hopefully, this will help someone else moving to this
  particular laptop. This is not a "look, linux sux" post. The Oryx
  Pro is a great machine, and is a far better experience than the
  overall Linux experience I remember from 2012.

*** Emacs is unusable due to constant movement of the cursor.
  - The cursor constantly moves to the end of the first line on screen
    for no apparent reason.
    + I'm convinced the reason that the cursor moves to the end of the
      first line on screen has to do with the position of the
      mouse-pointer. I confirmed this by changing `mouse-avoidance-mode'
      to `animate' (from `banish'). This stops the pointer from being
      moved to the top right corner on key press in Emacs. Now, the
      cursor does not move to the end of the first line like it used to,
      but to some other random place (wherever the mouse pointer
      happened to be last)
  - Repeatedly performing certain key-bindings (like C-n) causes a
    buffer menu to pop up. I have no idea why this happens and how to
    reproduce it / stop it.
    + Once the menu shows up, repeatedly pressing the same key-binding
      causes it to go away after some time. (This may be true only of
      C-n, which is what triggers this for me the most.)
  - *Update* : Both problems above are due to the awkward placing of the
    touchpad on the System 76 laptops. This touchpad is sensitive and
    registers "ghost clicks" during typing. I confirmed this by
    disabling my touchpad. The problem went away. This is an acceptable
    workaround for me as I don't need the mouse when I'm in Emacs (and
    disabling/enabling the touchpad is straightforward using =xinput=)
    + =xinput list= will list all the available input devices. Look for
      your touchpad and note the id of the device.
    + =xinput disable <id>= will disable the device.
    + =xinput enable <id>= will enable the device.

*** The space key is weird.
  - More than any other key on the laptop, the space key needs a solid
    thump for it to register. This is especially irritating when typing
    out passphrases, since there is no visible feedback.
  - *Update* : Over time, I've gotten used to this and no longer need to
    worry about whether my keypress has registered or not.

*** Power management and suspend.
**** No "just works" for Suspend.
  - Years of using the Mac have trained me to just shut the laptop lid
    when I'm done working. However, with Oryx, there is no predictable
    way to tell whether the battery will continue to be drained or not
    once the lid is down. I've left a fully charged laptop, come back to
    it 4 hours later to find that it was completely drained (to the
    point that it does not start unless you plug it into a power
    source). I have no clue why this happens.
    + *Update* : Apparently this is famous in the world of System76 as
      the 'suspend black screen of death' bug. :( These are the kind of
      things due to which 'year of the Linux desktop' is a broken
      promise.
  - *Update 2* : Suspend works okayish, it just drains the battery
    faster than I would have expected. I guess I'll have to learn to
    live with this (but it seriously hampers the use of this laptop as a
    carry-around device, which is something I'm grumpy about).
  - *Update 3* : Prolonged use of this laptop really makes me appreciate
    the incredible power management of the Macbook. I love Oryx as a
    development environment, but the Macbook's power management is in a
    whole different class.

**** The Power button is weird.
  - I've gotten into the habit of shutting down my laptop when I'm
    unsure about battery and want to definitely conserve it (example
    when I'm traveling). There is no immediate feedback on pressing the
    power button. Due to this, it's hard to know if the keypress has
    registered or not. This is a small gripe in the big picture, but it
    gets annoying fast.

  #  LocalWords:  touchpad keypress Macbook Oryx Macbook's okayish

** DRAFT Setting up email in Emacs using notmuch and mbsync :mbsync:notmuch:emacs:email:
   :PROPERTIES:
   :EXPORT_FILE_NAME: email-in-emacs-notmuch-mbsync
   :END:
   :LOGBOOK:
   - Note taken on [2020-03-25 Wed 22:44] \\
     - Jotted down original idea and an initial draft on <2019-05-27 Mon>
   :END:
*** Installing notmuch
    - sudo apt install notmuch
**** Create the notmuch config file
**** Load notmuch.el when running emacs
*** Installing mbsync
    - sudo apt install isync
**** Create the mbsync config file
*** Installing msmtp
    - sudo apt install msmtp
**** Create the msmtp config file
**** Set the sendmail program to msmtp in Emacs
*** Create a script to sync email and index it.
    - nmgetmail.sh
    - install a cron for this.

** TODO Project planning in Plain Text :taskjuggler:mermaidjs:gantt:emacs:orgmode:

   :PROPERTIES:
   :EXPORT_SUBTITLE: "Organizing your planning in org-mode."
   :EXPORT_FILE_NAME: project-planning-in-plain-text
   :END:
   :LOGBOOK:
   - Note taken on [2020-03-25 Wed 22:38] \\
     - Jotted down the original idea on <2019-04-06 Sat>
   :END:
*** Points
    - Gantt charts are a very effective planning tool
    - Everyone ends up on gantt charts:
      + manually maintain an excel sheet
      + use professional (and expensive) tool for all or part of your
        project planning: MS Project, Project Plan 365.
    - Wouldn't it be great to have this in plain text?
      + mermaidjs
      + ^ Great tool. Easy to write plain text gantt charts and see the
        visualization.
      + Where do we store this information? I want it to be a part of
        the day to day work I'm doing.
    - Enter org-mode
      + Incredible tool for personal planning, note taking, task tracking
      + Missing visualization tools, but has all the tools to hook things together.
      + Let's get to work connecting org-mode and mermaidjs
    - What we get
      + Add source blocks anywhere in your org-file, as you would normally do.
      + All the data is available for you to read within context.
      + Dealing with dates in Org is a breeze.
    - What are the pain points?
      + Tangle the org-file, Process the generated file, Evaluate the processed file
        - Too many manual steps
      + Adding new sections means you have to remember to add the
        section to the tangle block in the correct order.
    - What is missing
      + Being able to add a leave for 2 days in the middle of a planned
        project and have relevant plans automatically adjust. Need to
        check if tools support this.


  #+hugo: more

  Gantt Charts are the best.

* Tiny Logs                                                        :@tinylog:
  :PROPERTIES:
  :EXPORT_HUGO_SECTION: blog
  :END:
** DONE Tinylog: Mbsync: Error: Channel <x> Is Locked                :mbsync:
   CLOSED: [2017-10-11 Wed 19:22]
   :PROPERTIES:
   :EXPORT_FILE_NAME: mbsync-channel-is-locked
   :END:
You may come across the following error when running ~mbsync~ :

#+begin_example
  Error: channel :<channel-name>-remote:<folder>-:<channel-name>-local:<folder> is locked
#+end_example

This happens when there is another ~mbsync~ instance running in
parallel and it has taken a lock on the particular folder. In my case,
I am running ~mbsync~ via a cron-job, and it tends to leave dead
instances around if the laptop sleeps during a run. Kill all instances
of ~mbsync~ and restart the process and you should be fine!
* Notes                                                               :@notes:
  :PROPERTIES:
  :EXPORT_HUGO_SECTION: blog
  :END:
** TODO Lazy Weekend Reading: API design and the Scikit-learn project   :api:
   :LOGBOOK:
   - Note taken on [2020-03-25 Wed 23:17] \\
     - Original idea was on <2020-02-09 Sun>
   :END:
** DONE Lazy Weekend Reading: A love letter to Clojure  :programming:clojure:
   CLOSED: [2019-10-13 Sun 23:02]
   :PROPERTIES:
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :toc true
   :EXPORT_FILE_NAME: love-letter-to-clojure
   :END:
I had no idea that /Gene Kim/, author of three books that have
garnered wide-spread public acclaim, was doing Clojure programming.
(They are DevOps Handbook, Phoenix Project, and Accelerate -- we've
ordered them recently for the Helpshift Library). He published [[https://itrevolution.com/love-letter-to-clojure-part-1/][a
love-letter to Clojure]] this weekend, and I think it is an absolute
must-read for *all programmers* (whether you write Clojure or not).
The blog-post covers the following areas:

*** General software philosophy
  - Choose tools that are good to *think* with
  - Most bugs are due to programmers not understanding all the possible
    states their code may execute in. *Make state and it's mutation
    explicit*. Put it in a specific place and mutate it with a small set
    of specific functions.
  - *Conventions matter*. They help readability of code, which is critical.
  - *Make systems simple to change*. Don't "trap yourself in a system of
    work where you can no longer solve real business problems easily.
    Instead, youre forced to merely solve puzzles all day, trying to
    figure out how to make your small change, obstructed by your
    complected system".
  - Developer productivity is enhanced when they follow the ideals
    listed below. Invisible structures around us either help or hinder
    in this regard.
    + The first ideal: *Locality and Simplicity*
    + The second ideal: *Focus, Flow and Joy*
    + The third ideal: *Improvement of Daily Work*
    + The fourth ideal: *Psychological Safety*
    + The fifth ideal: *Customer Focus*
  - "Practice as a transcendental experience" and "Practice as hard work
    and perseverance" are both needed for developers to level up.
  - Bugs can be introduced by not understanding programming language
    constructs (eg: in Ruby, strings are mutated if you use the <<
    operator).
*** Specific Programming Practices
  - *Pure functions are trivial to test* -- build input, look at output.
    If it's hard to write a test for your code, that's a sign that it is
    complicated. Try to simplify it by pulling pure functions out of it
    and writing tests for those.
  - *Push side-effects (impure functions) to the edge of the program* /
    piece of code that you are writing. Not practicing this leads to
    code becoming increasingly untestable and difficult to change.
    + example of good vs bad way:
      #+begin_src clojure

        ;; good way: steps are composed together, which each compiler phase
        ;; indepdendently executable and testable.

        (-> (tokenize-source-files!)
            (generate-abstract-syntax-tree)
            (generate-intermediate-representation)
            (generate-assembly-instructions)
            (write-assembly-output-files!))

        ;; bad way: all the intermediate steps buried inside other functions,
        ;; no longer reachable or inspectable.

        tokenize-source-files-and-generate-ir-and-generate-assembly();
      #+end_src
  - Pushing I/O to edges reduces the need for mocks and stubs
*** The Joy of Clojure
  - Ease of writing short, beautiful code that just works.
  - Simpler syntax frees your brain to think about the problem you want
    to solve.
  - The REPL experience enables developer to stay focused and in flow
    state. The developer experiences joy in REPL driven development.
  - Clojure is a high-level language that gets out of your way. "A
    programming language is low-level when its programs require
    attention to the irrelevant." - Alan Perlis
*** Other notes
  - The brightest days of infrastructure, operations and security are
    still ahead of us. They involve providing platforms to developers
    that hide the complexity of these things and allow the developer to
    focus on the business problem they want to solve.
*** Links to other superb resources for more reading
  - Some great blog-posts:
    + Bryan Cantrell: [[https://twitter.com/bcantrill/status/1042180114199375872][A love letter to Rust]] (which inspired this post)
    + John Carmack: [[http://www.gamasutra.com/view/news/169296/Indepth%5C_Functional%5C_programming%5C_in%5C_C.php][The power of functional programming concepts in C++]]
    + Shu Uesugi and Julien Benchetrit: [[https://medium.freecodecamp.org/react-introduction-for-people-who-know-just-enough-jquery-to-get-by-2019-version-28a4b4316d1a][An Introduction to React in 2019 (For People Who Know Just Enough jQuery To Get By)]]
    + Uncle Bob Martin: [[https://blog.cleancoder.com/uncle-bob/2019/08/22/WhyClojure.html][Why Clojure?]]
  - Some great videos:
    + John Carmack: [[https://youtu.be/1PhArSujR_A][Rewriting Wolfenstein 3D using functional programming techniques]]
    + Rich Hickey: [[https://www.infoq.com/presentations/Simple-Made-Easy/][Simple Made Easy]]
    + Dr. Mihaly Csikszentmihalyi: [[https://www.ted.com/talks/mihaly_csikszentmihalyi_on_flow?language=en][TED talk on the flow state]]
    + Brian Goetz: [[https://youtu.be/2y5Pv4yN0b0][Stewardship of the Java ecosystem]]
    + Rafal Dittwald: [[https://youtu.be/vK1DazRK_a0][Solving problems the Clojure way]]
    + Bruce Hauman: [[https://youtu.be/j-kj2qwJa_E][Talking about figwheel for Clojurescript development]]
    + Sean Corfield: [[https://www.youtube.com/embed/UFY2rd05W2g][Using the REPL to debug a problem in core.memoize]]
    + Tiago Luchini: [[https://youtu.be/EDojA_fahvM][Writing declarative domain models]]
    + David Nolen: [[https://www.youtube.com/watch?v=77b47P8EpfA][Rethinking Identity]]
  - Some great books:
    + Michael Nygard: =Release it!=
    + Chas Emerick, Brian Carper, Christophe Grand: =Clojure Programming=
    + Russ Olsen: =Getting Clojure=
    + Brian Goetz: =Java Concurrency in Practice=
    + Martin Fowler: =Refactoring: Improving the design of existing code=
    + Dr. Mihaly Csikszentmihalyi: =Flow: The psychology of optimal experience=
    + Daniel Higgenbottom: =Clojure for the brave and true=
    + Carin Meier: =Living Clojure=
    + Mark Schwartz: =Seat at the table: IT leadership in the age of agility=
  - Clojure tutorials:
    + Eric Normand: [[https://purelyfunctional.tv][Purely Functional]]
    + Arne Brasseur: [[https://lambdaisland.com][Lambda Island]]
* Random                                                            :@random:
  :PROPERTIES:
  :EXPORT_HUGO_SECTION: blog
  :END:
** DRAFT Best Laid Plans And                             :true_stories:
   :PROPERTIES:
   :EXPORT_FILE_NAME: best-laid-plans-and-
   :END:
   :LOGBOOK:
   - Note taken on [2020-03-25 Wed 23:20] \\
     - Happened on <2017-08-14 Mon>
     - Jotted down <2017-08-19 Sat 13:30>
   :END:
- 14th August.
- wifey is staying at her parents tonight, because there's a pooja she
  needs to perform early next morning.
- looking forward to a long uninterrupted work session, followed by a
  relaxed tuesday.
- "Vedang, you should go to Akku Maushi's place today." Why? It's
  Gokulashtami today!
- Okay, I'll leave early and take the Bullet. I'll beat the ridiculous
  traffic, go meet Akku Maushi and Shree Kaka, offer my prayers and
  leave in half an hour, be back home in two and a half hours total.
- I also haven't driven the Bullet all this rainy season, so two birds
  with one stone! Vedang you're a genius.
- I did leave early and I did beat the traffic! Yes! I was at Akku
  Maushi's home at 6 pm on the dot. I could be back home by 7:30 pm!
- I imagined I would be alone. I was wrong. Many of my uncles and
  aunts were there. As was my mom!
- So instead of leaving at 6:30 pm, I ended up staying till 7:30 pm.
  Not gonna lie, I was super pampered and loved every minute of it. It
  was fun talking to everyone.
- "Vedang, since you're here, come home with me. Drop me home, have
  dinner and then leave."
- "No, mother, I have work to finish today. If I stay for dinner then
  it'll be too late getting back home and I won't get anything done."
- "Okay, then drop me to Swargate so that I can catch a bus home."
  "Yes, will do."
- As we approach the Swargate bus station, we see the 21 number bus
  that would have taken my Aai home leave. We've missed the bus by a
  minute! I wait with my mother and chat about everyone at home until
  the next bus arrives. It's 8:30 pm now.
- Okay, mom's on her way home. Now let's ride home and get to work!
- No! No! No! the bullet's out of petrol!
- Okay no worries,
* Interviews                                                    :@interviews:
  :PROPERTIES:
  :EXPORT_HUGO_SECTION: blog
  :END:
** DONE Imagine Working in Engineering at Helpshift       :culture:helpshift:
   CLOSED: [2017-09-07 Thu 07:27]
   :PROPERTIES:
   :EXPORT_HUGO_CUSTOM_FRONT_MATTER: :toc true
   :EXPORT_FILE_NAME: imagine-working-in-engineering-at-helpshift
   :END:
/Cross-posted from my interview published on [[https://medium.com/@helpshift/image-ine-working-in-engineering-at-helpshift-8818247e2188][Helpshift's Medium blog]]/

- Name: Vedang Manerikar
- Current Role: Principal Engineering Manager, Backend
- How long you have been with Helpshift?: 7 years

#+hugo: more

*** What does your day-to-day at Helpshift look like?
    My day-to-day is unblocking people and getting things done!

    I review architecture, read code, enable customer service, help
    product guys understand the engineering pros and cons of their
    product decisions and prioritize work for maximum productivity. I
    work with an amazing team. They make all of this possible and
    achievable.

    That means I also get to hang out with my best friends, catch up
    on their day-to-day, laugh at inside jokes that have been running
    for years and overall have a blast. Seven years at a place lets
    you build deep relationships and puts a smile on your face when
    you think about work!

*** What has been your favorite off-site team oriented event, and why?
    When we were cash-strapped and raising funds, a team off-site was
    the running joke of the company. "After Series A!", we would raise
    our glasses and say. As time went on without funding in sight,
    every request turned into "After Series A!".

    So when we did raise our first round, we treated ourselves to a
    long weekend at a spectacular villa in Goa. It was a heady
    celebration and the world was our oyster. It remains my favorite
    off-site because the funding felt like validation.

*** What role(s) did you start in at Helpshift and how have you graduated/migrated into different roles?
    I came to Helpshift with a strong systems background: writing
    kernel modules and working on storage replication. I started
    writing Python at Helpshift and then graduated to Clojure (in
    2011, when almost no one else was writing Clojure). I've since
    written and helped design large chunks of the Helpshift
    architecture, and have learnt interesting things about distributed
    systems through trial-by-fire. Today, I make an impact by making
    sure my team has clear, unambiguous goals and all the resources to
    achieve these goals.

*** Favorite thing about working for an SF tech startup:
    I have a lot of "favorite things" about working at Helpshift (We
    keep our workplace fun!). A small example of this is that on any
    given day someone or the other will bring home-made snacks and
    goodies for the others to enjoy.

*** What advice would you have for prospective Helpshift candidates?
    We're still a small enough company that everyone knows everyone
    else by name. If you're the kind of person who wants to get in on
    the ground floor and grow with a company, we're perfect for you.
    Come with a no-nonsense, no-bullshit attitude. Be a kind person.

*** What is your proudest moment at Helpshift?
    My colleagues and I have taken this company from serving 0
    requests per second to serving 50,000 requests per second. We're
    installed in over 2 Billion devices in the world. That means that
    there's a 50% chance that you (reader) have us installed in one of
    the apps on your phone. That sentence is a source of great pride
    for me.

*** How would you describe the company culture and what do you like most about it?
    As a company, we've always looked for attitude over smarts. We
    want people who are good listeners and good communicators. We want
    people who are passionate and hold strong opinions. We want people
    who care about quality. This is the culture that we've always
    striven to maintain at Helpshift.

*** Superpower (real or fake): Obscure Emacs shortcuts.
    Give a man Emacs and he'll get some programming done. Teach a man
    how to tweak it and play with it and he'll happily shave yaks for
    the rest of his life.

*** Slightly addicted to: Tea.
    Walking out of the office to have road-side tea in the evening is
    an old Helpshift tradition. I'm always on the lookout for great
    Masala Chai, and if you come to my home I'll whip up a fantastic
    cup of tea for us to chat over!

*** Always on the search for the perfect: new book to read.
    Reading is one of my favorite ways to unwind. I read anything that
    I can get my hands on: fantasies, travelogues, thrillers, pop
    psychology, autobiographies, technical books, comics, you name it!

*** If you could interview one person, dead or alive, who would it be and why?
    Isaac Newton or Albert Einstein or Alan Turing! (Sorry I cheated.)
    These were phenomenal people with world-changing ideas. How did
    they get them? How did they remain productive all their life? What
    did "work" mean for them? What was their work day like? What did
    they do to unwind? What did they do for leisure? Who did _they_
    look up to? I'd love to know these answers!
